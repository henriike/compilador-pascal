Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CASE
    COMMENT
    DIVIDE_INT
    DOWNTO
    EXP
    FALSE
    FOR
    LBRACKET
    OF
    RBRACKET
    RESERVED
    SCORE
    TO
    TRUE

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID SEMICOLON block
Rule 2     program -> PROGRAM ID SEMICOLON
Rule 3     block -> const_declaration_part var_declaration_part subroutine_declaration_part compound_statement
Rule 4     const_declaration_part -> CONST const_definition
Rule 5     const_declaration_part -> <empty>
Rule 6     const_definition -> ID EQUALS types SEMICOLON const_definition
Rule 7     const_definition -> ID EQUALS types SEMICOLON
Rule 8     var_declaration_part -> VAR var_declaration
Rule 9     var_declaration_part -> <empty>
Rule 10    var_declaration -> identifier_list TWOPOINTS types SEMICOLON var_declaration
Rule 11    var_declaration -> identifier_list TWOPOINTS types SEMICOLON
Rule 12    types -> INTEGER
Rule 13    types -> REAL
Rule 14    types -> STRING
Rule 15    types -> BOOLEAN
Rule 16    types -> CHAR
Rule 17    types -> ID
Rule 18    identifier_list -> ID
Rule 19    identifier_list -> ID COMMA identifier_list
Rule 20    subroutine_declaration_part -> procedure_declaration subroutine_declaration_part
Rule 21    subroutine_declaration_part -> function_declaration subroutine_declaration_part
Rule 22    subroutine_declaration_part -> <empty>
Rule 23    procedure_declaration -> PROCEDURE ID LPARENT param_section RPARENT SEMICOLON
Rule 24    function_declaration -> FUNCTION ID LPARENT param_section RPARENT TWOPOINTS types SEMICOLON
Rule 25    param_section -> identifier_list TWOPOINTS types SEMICOLON param_section
Rule 26    param_section -> <empty>
Rule 27    compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON
Rule 28    compound_statement -> BEGIN statement END SEMICOLON
Rule 29    statement -> assign_statement statement
Rule 30    statement -> procedure_call statement
Rule 31    statement -> if_statement statement
Rule 32    statement -> while_statement statement
Rule 33    statement -> repeat_statement statement
Rule 34    statement -> compound_statement statement
Rule 35    statement -> <empty>
Rule 36    assign_statement -> ID ASSIGNMENT expr SEMICOLON
Rule 37    procedure_call -> ID LPARENT expr_list RPARENT SEMICOLON
Rule 38    if_statement -> if1
Rule 39    if_statement -> if2
Rule 40    if1 -> IF expr_list THEN if1 ELSE if1
Rule 41    if1 -> <empty>
Rule 42    if2 -> IF expr_list THEN if_statement
Rule 43    if2 -> IF expr_list THEN if1 ELSE if2
Rule 44    while_statement -> WHILE expr DO statement
Rule 45    repeat_statement -> REPEAT statement UNTIL expr
Rule 46    expr_list -> expr
Rule 47    expr_list -> expr COMMA expr_list
Rule 48    expr -> simple_expr relop_simple_expr
Rule 49    relop_simple_expr -> relop simple_expr relop_simple_expr
Rule 50    relop_simple_expr -> <empty>
Rule 51    relop -> EQUALS
Rule 52    relop -> LTHAN
Rule 53    relop -> GTHAN
Rule 54    relop -> DIFFERENT
Rule 55    relop -> GEQUALS
Rule 56    relop -> LEQUALS
Rule 57    simple_expr -> uplus_uminus factor
Rule 58    simple_expr -> uplus_uminus factor addop_mulop factor simple_expr
Rule 59    uplus_uminus -> UPLUS
Rule 60    uplus_uminus -> UMINUS
Rule 61    uplus_uminus -> <empty>
Rule 62    addop_mulop -> PLUS
Rule 63    addop_mulop -> MINUS
Rule 64    addop_mulop -> OR
Rule 65    addop_mulop -> TIMES
Rule 66    addop_mulop -> DIVIDE
Rule 67    addop_mulop -> DIV
Rule 68    addop_mulop -> MOD
Rule 69    addop_mulop -> AND
Rule 70    addop_mulop -> <empty>
Rule 71    factor -> ID
Rule 72    factor -> INTEGER
Rule 73    factor -> REAL
Rule 74    factor -> STRING
Rule 75    factor -> NOT factor
Rule 76    factor -> <empty>

Terminals, with rules where they appear

AND                  : 69
ARRAY                : 
ASSIGNMENT           : 36
BEGIN                : 27 28
BOOLEAN              : 15
CASE                 : 
CHAR                 : 16
COMMA                : 19 47
COMMENT              : 
CONST                : 4
DIFFERENT            : 54
DIV                  : 67
DIVIDE               : 66
DIVIDE_INT           : 
DO                   : 44
DOWNTO               : 
ELSE                 : 40 43
END                  : 27 28
EQUALS               : 6 7 51
EXP                  : 
FALSE                : 
FOR                  : 
FUNCTION             : 24
GEQUALS              : 55
GTHAN                : 53
ID                   : 1 2 6 7 17 18 19 23 24 36 37 71
IF                   : 40 42 43
INTEGER              : 12 72
LBRACKET             : 
LEQUALS              : 56
LPARENT              : 23 24 37
LTHAN                : 52
MINUS                : 63
MOD                  : 68
NOT                  : 75
OF                   : 
OR                   : 64
PLUS                 : 62
PROCEDURE            : 23
PROGRAM              : 1 2
RBRACKET             : 
REAL                 : 13 73
REPEAT               : 45
RESERVED             : 
RPARENT              : 23 24 37
SCORE                : 
SEMICOLON            : 1 2 6 7 10 11 23 24 25 27 27 28 36 37
STRING               : 14 74
THEN                 : 40 42 43
TIMES                : 65
TO                   : 
TRUE                 : 
TWOPOINTS            : 10 11 24 25
UMINUS               : 60
UNTIL                : 45
UPLUS                : 59
VAR                  : 8
WHILE                : 44
error                : 

Nonterminals, with rules where they appear

addop_mulop          : 58
assign_statement     : 29
block                : 1
compound_statement   : 3 34
const_declaration_part : 3
const_definition     : 4 6
expr                 : 36 44 45 46 47
expr_list            : 37 40 42 43 47
factor               : 57 58 58 75
function_declaration : 21
identifier_list      : 10 11 19 25
if1                  : 38 40 40 43
if2                  : 39 43
if_statement         : 31 42
param_section        : 23 24 25
procedure_call       : 30
procedure_declaration : 20
program              : 0
relop                : 49
relop_simple_expr    : 48 49
repeat_statement     : 33
simple_expr          : 48 49 58
statement            : 27 27 28 29 30 31 32 33 34 44 45
subroutine_declaration_part : 3 20 21
types                : 6 7 10 11 24 25
uplus_uminus         : 57 58
var_declaration      : 8 10
var_declaration_part : 3
while_statement      : 32

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID SEMICOLON block
    (2) program -> . PROGRAM ID SEMICOLON

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID SEMICOLON block
    (2) program -> PROGRAM . ID SEMICOLON

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . SEMICOLON block
    (2) program -> PROGRAM ID . SEMICOLON

    SEMICOLON       shift and go to state 4


state 4

    (1) program -> PROGRAM ID SEMICOLON . block
    (2) program -> PROGRAM ID SEMICOLON .
    (3) block -> . const_declaration_part var_declaration_part subroutine_declaration_part compound_statement
    (4) const_declaration_part -> . CONST const_definition
    (5) const_declaration_part -> .

    $end            reduce using rule 2 (program -> PROGRAM ID SEMICOLON .)
    CONST           shift and go to state 7
    VAR             reduce using rule 5 (const_declaration_part -> .)
    PROCEDURE       reduce using rule 5 (const_declaration_part -> .)
    FUNCTION        reduce using rule 5 (const_declaration_part -> .)
    BEGIN           reduce using rule 5 (const_declaration_part -> .)

    block                          shift and go to state 5
    const_declaration_part         shift and go to state 6

state 5

    (1) program -> PROGRAM ID SEMICOLON block .

    $end            reduce using rule 1 (program -> PROGRAM ID SEMICOLON block .)


state 6

    (3) block -> const_declaration_part . var_declaration_part subroutine_declaration_part compound_statement
    (8) var_declaration_part -> . VAR var_declaration
    (9) var_declaration_part -> .

    VAR             shift and go to state 9
    PROCEDURE       reduce using rule 9 (var_declaration_part -> .)
    FUNCTION        reduce using rule 9 (var_declaration_part -> .)
    BEGIN           reduce using rule 9 (var_declaration_part -> .)

    var_declaration_part           shift and go to state 8

state 7

    (4) const_declaration_part -> CONST . const_definition
    (6) const_definition -> . ID EQUALS types SEMICOLON const_definition
    (7) const_definition -> . ID EQUALS types SEMICOLON

    ID              shift and go to state 11

    const_definition               shift and go to state 10

state 8

    (3) block -> const_declaration_part var_declaration_part . subroutine_declaration_part compound_statement
    (20) subroutine_declaration_part -> . procedure_declaration subroutine_declaration_part
    (21) subroutine_declaration_part -> . function_declaration subroutine_declaration_part
    (22) subroutine_declaration_part -> .
    (23) procedure_declaration -> . PROCEDURE ID LPARENT param_section RPARENT SEMICOLON
    (24) function_declaration -> . FUNCTION ID LPARENT param_section RPARENT TWOPOINTS types SEMICOLON

    BEGIN           reduce using rule 22 (subroutine_declaration_part -> .)
    PROCEDURE       shift and go to state 15
    FUNCTION        shift and go to state 16

    subroutine_declaration_part    shift and go to state 12
    procedure_declaration          shift and go to state 13
    function_declaration           shift and go to state 14

state 9

    (8) var_declaration_part -> VAR . var_declaration
    (10) var_declaration -> . identifier_list TWOPOINTS types SEMICOLON var_declaration
    (11) var_declaration -> . identifier_list TWOPOINTS types SEMICOLON
    (18) identifier_list -> . ID
    (19) identifier_list -> . ID COMMA identifier_list

    ID              shift and go to state 19

    var_declaration                shift and go to state 17
    identifier_list                shift and go to state 18

state 10

    (4) const_declaration_part -> CONST const_definition .

    VAR             reduce using rule 4 (const_declaration_part -> CONST const_definition .)
    PROCEDURE       reduce using rule 4 (const_declaration_part -> CONST const_definition .)
    FUNCTION        reduce using rule 4 (const_declaration_part -> CONST const_definition .)
    BEGIN           reduce using rule 4 (const_declaration_part -> CONST const_definition .)


state 11

    (6) const_definition -> ID . EQUALS types SEMICOLON const_definition
    (7) const_definition -> ID . EQUALS types SEMICOLON

    EQUALS          shift and go to state 20


state 12

    (3) block -> const_declaration_part var_declaration_part subroutine_declaration_part . compound_statement
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON

    BEGIN           shift and go to state 22

    compound_statement             shift and go to state 21

state 13

    (20) subroutine_declaration_part -> procedure_declaration . subroutine_declaration_part
    (20) subroutine_declaration_part -> . procedure_declaration subroutine_declaration_part
    (21) subroutine_declaration_part -> . function_declaration subroutine_declaration_part
    (22) subroutine_declaration_part -> .
    (23) procedure_declaration -> . PROCEDURE ID LPARENT param_section RPARENT SEMICOLON
    (24) function_declaration -> . FUNCTION ID LPARENT param_section RPARENT TWOPOINTS types SEMICOLON

    BEGIN           reduce using rule 22 (subroutine_declaration_part -> .)
    PROCEDURE       shift and go to state 15
    FUNCTION        shift and go to state 16

    procedure_declaration          shift and go to state 13
    subroutine_declaration_part    shift and go to state 23
    function_declaration           shift and go to state 14

state 14

    (21) subroutine_declaration_part -> function_declaration . subroutine_declaration_part
    (20) subroutine_declaration_part -> . procedure_declaration subroutine_declaration_part
    (21) subroutine_declaration_part -> . function_declaration subroutine_declaration_part
    (22) subroutine_declaration_part -> .
    (23) procedure_declaration -> . PROCEDURE ID LPARENT param_section RPARENT SEMICOLON
    (24) function_declaration -> . FUNCTION ID LPARENT param_section RPARENT TWOPOINTS types SEMICOLON

    BEGIN           reduce using rule 22 (subroutine_declaration_part -> .)
    PROCEDURE       shift and go to state 15
    FUNCTION        shift and go to state 16

    function_declaration           shift and go to state 14
    subroutine_declaration_part    shift and go to state 24
    procedure_declaration          shift and go to state 13

state 15

    (23) procedure_declaration -> PROCEDURE . ID LPARENT param_section RPARENT SEMICOLON

    ID              shift and go to state 25


state 16

    (24) function_declaration -> FUNCTION . ID LPARENT param_section RPARENT TWOPOINTS types SEMICOLON

    ID              shift and go to state 26


state 17

    (8) var_declaration_part -> VAR var_declaration .

    PROCEDURE       reduce using rule 8 (var_declaration_part -> VAR var_declaration .)
    FUNCTION        reduce using rule 8 (var_declaration_part -> VAR var_declaration .)
    BEGIN           reduce using rule 8 (var_declaration_part -> VAR var_declaration .)


state 18

    (10) var_declaration -> identifier_list . TWOPOINTS types SEMICOLON var_declaration
    (11) var_declaration -> identifier_list . TWOPOINTS types SEMICOLON

    TWOPOINTS       shift and go to state 27


state 19

    (18) identifier_list -> ID .
    (19) identifier_list -> ID . COMMA identifier_list

    TWOPOINTS       reduce using rule 18 (identifier_list -> ID .)
    COMMA           shift and go to state 28


state 20

    (6) const_definition -> ID EQUALS . types SEMICOLON const_definition
    (7) const_definition -> ID EQUALS . types SEMICOLON
    (12) types -> . INTEGER
    (13) types -> . REAL
    (14) types -> . STRING
    (15) types -> . BOOLEAN
    (16) types -> . CHAR
    (17) types -> . ID

    INTEGER         shift and go to state 31
    REAL            shift and go to state 32
    STRING          shift and go to state 33
    BOOLEAN         shift and go to state 34
    CHAR            shift and go to state 35
    ID              shift and go to state 29

    types                          shift and go to state 30

state 21

    (3) block -> const_declaration_part var_declaration_part subroutine_declaration_part compound_statement .

    $end            reduce using rule 3 (block -> const_declaration_part var_declaration_part subroutine_declaration_part compound_statement .)


state 22

    (27) compound_statement -> BEGIN . statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> BEGIN . statement END SEMICOLON
    (29) statement -> . assign_statement statement
    (30) statement -> . procedure_call statement
    (31) statement -> . if_statement statement
    (32) statement -> . while_statement statement
    (33) statement -> . repeat_statement statement
    (34) statement -> . compound_statement statement
    (35) statement -> .
    (36) assign_statement -> . ID ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> . ID LPARENT expr_list RPARENT SEMICOLON
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (44) while_statement -> . WHILE expr DO statement
    (45) repeat_statement -> . REPEAT statement UNTIL expr
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for END resolved using rule 35 (statement -> .)
    SEMICOLON       reduce using rule 35 (statement -> .)
    END             reduce using rule 35 (statement -> .)
    ID              shift and go to state 43
    WHILE           shift and go to state 46
    REPEAT          shift and go to state 47
    BEGIN           shift and go to state 22
    IF              shift and go to state 48

  ! ID              [ reduce using rule 41 (if1 -> .) ]
  ! WHILE           [ reduce using rule 41 (if1 -> .) ]
  ! REPEAT          [ reduce using rule 41 (if1 -> .) ]
  ! BEGIN           [ reduce using rule 41 (if1 -> .) ]
  ! IF              [ reduce using rule 41 (if1 -> .) ]
  ! SEMICOLON       [ reduce using rule 41 (if1 -> .) ]
  ! END             [ reduce using rule 41 (if1 -> .) ]

    statement                      shift and go to state 36
    assign_statement               shift and go to state 37
    procedure_call                 shift and go to state 38
    if_statement                   shift and go to state 39
    while_statement                shift and go to state 40
    repeat_statement               shift and go to state 41
    compound_statement             shift and go to state 42
    if1                            shift and go to state 44
    if2                            shift and go to state 45

state 23

    (20) subroutine_declaration_part -> procedure_declaration subroutine_declaration_part .

    BEGIN           reduce using rule 20 (subroutine_declaration_part -> procedure_declaration subroutine_declaration_part .)


state 24

    (21) subroutine_declaration_part -> function_declaration subroutine_declaration_part .

    BEGIN           reduce using rule 21 (subroutine_declaration_part -> function_declaration subroutine_declaration_part .)


state 25

    (23) procedure_declaration -> PROCEDURE ID . LPARENT param_section RPARENT SEMICOLON

    LPARENT         shift and go to state 49


state 26

    (24) function_declaration -> FUNCTION ID . LPARENT param_section RPARENT TWOPOINTS types SEMICOLON

    LPARENT         shift and go to state 50


state 27

    (10) var_declaration -> identifier_list TWOPOINTS . types SEMICOLON var_declaration
    (11) var_declaration -> identifier_list TWOPOINTS . types SEMICOLON
    (12) types -> . INTEGER
    (13) types -> . REAL
    (14) types -> . STRING
    (15) types -> . BOOLEAN
    (16) types -> . CHAR
    (17) types -> . ID

    INTEGER         shift and go to state 31
    REAL            shift and go to state 32
    STRING          shift and go to state 33
    BOOLEAN         shift and go to state 34
    CHAR            shift and go to state 35
    ID              shift and go to state 29

    types                          shift and go to state 51

state 28

    (19) identifier_list -> ID COMMA . identifier_list
    (18) identifier_list -> . ID
    (19) identifier_list -> . ID COMMA identifier_list

    ID              shift and go to state 19

    identifier_list                shift and go to state 52

state 29

    (17) types -> ID .

    SEMICOLON       reduce using rule 17 (types -> ID .)


state 30

    (6) const_definition -> ID EQUALS types . SEMICOLON const_definition
    (7) const_definition -> ID EQUALS types . SEMICOLON

    SEMICOLON       shift and go to state 53


state 31

    (12) types -> INTEGER .

    SEMICOLON       reduce using rule 12 (types -> INTEGER .)


state 32

    (13) types -> REAL .

    SEMICOLON       reduce using rule 13 (types -> REAL .)


state 33

    (14) types -> STRING .

    SEMICOLON       reduce using rule 14 (types -> STRING .)


state 34

    (15) types -> BOOLEAN .

    SEMICOLON       reduce using rule 15 (types -> BOOLEAN .)


state 35

    (16) types -> CHAR .

    SEMICOLON       reduce using rule 16 (types -> CHAR .)


state 36

    (27) compound_statement -> BEGIN statement . SEMICOLON statement END SEMICOLON
    (28) compound_statement -> BEGIN statement . END SEMICOLON

    SEMICOLON       shift and go to state 54
    END             shift and go to state 55


state 37

    (29) statement -> assign_statement . statement
    (29) statement -> . assign_statement statement
    (30) statement -> . procedure_call statement
    (31) statement -> . if_statement statement
    (32) statement -> . while_statement statement
    (33) statement -> . repeat_statement statement
    (34) statement -> . compound_statement statement
    (35) statement -> .
    (36) assign_statement -> . ID ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> . ID LPARENT expr_list RPARENT SEMICOLON
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (44) while_statement -> . WHILE expr DO statement
    (45) repeat_statement -> . REPEAT statement UNTIL expr
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for END resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for UNTIL resolved using rule 35 (statement -> .)
    SEMICOLON       reduce using rule 35 (statement -> .)
    END             reduce using rule 35 (statement -> .)
    UNTIL           reduce using rule 35 (statement -> .)
    ID              shift and go to state 43
    WHILE           shift and go to state 46
    REPEAT          shift and go to state 47
    BEGIN           shift and go to state 22
    IF              shift and go to state 48

  ! ID              [ reduce using rule 35 (statement -> .) ]
  ! WHILE           [ reduce using rule 35 (statement -> .) ]
  ! REPEAT          [ reduce using rule 35 (statement -> .) ]
  ! BEGIN           [ reduce using rule 35 (statement -> .) ]
  ! IF              [ reduce using rule 35 (statement -> .) ]
  ! ID              [ reduce using rule 41 (if1 -> .) ]
  ! WHILE           [ reduce using rule 41 (if1 -> .) ]
  ! REPEAT          [ reduce using rule 41 (if1 -> .) ]
  ! BEGIN           [ reduce using rule 41 (if1 -> .) ]
  ! IF              [ reduce using rule 41 (if1 -> .) ]
  ! SEMICOLON       [ reduce using rule 41 (if1 -> .) ]
  ! END             [ reduce using rule 41 (if1 -> .) ]
  ! UNTIL           [ reduce using rule 41 (if1 -> .) ]

    assign_statement               shift and go to state 37
    statement                      shift and go to state 56
    procedure_call                 shift and go to state 38
    if_statement                   shift and go to state 39
    while_statement                shift and go to state 40
    repeat_statement               shift and go to state 41
    compound_statement             shift and go to state 42
    if1                            shift and go to state 44
    if2                            shift and go to state 45

state 38

    (30) statement -> procedure_call . statement
    (29) statement -> . assign_statement statement
    (30) statement -> . procedure_call statement
    (31) statement -> . if_statement statement
    (32) statement -> . while_statement statement
    (33) statement -> . repeat_statement statement
    (34) statement -> . compound_statement statement
    (35) statement -> .
    (36) assign_statement -> . ID ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> . ID LPARENT expr_list RPARENT SEMICOLON
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (44) while_statement -> . WHILE expr DO statement
    (45) repeat_statement -> . REPEAT statement UNTIL expr
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for END resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for UNTIL resolved using rule 35 (statement -> .)
    SEMICOLON       reduce using rule 35 (statement -> .)
    END             reduce using rule 35 (statement -> .)
    UNTIL           reduce using rule 35 (statement -> .)
    ID              shift and go to state 43
    WHILE           shift and go to state 46
    REPEAT          shift and go to state 47
    BEGIN           shift and go to state 22
    IF              shift and go to state 48

  ! ID              [ reduce using rule 35 (statement -> .) ]
  ! WHILE           [ reduce using rule 35 (statement -> .) ]
  ! REPEAT          [ reduce using rule 35 (statement -> .) ]
  ! BEGIN           [ reduce using rule 35 (statement -> .) ]
  ! IF              [ reduce using rule 35 (statement -> .) ]
  ! ID              [ reduce using rule 41 (if1 -> .) ]
  ! WHILE           [ reduce using rule 41 (if1 -> .) ]
  ! REPEAT          [ reduce using rule 41 (if1 -> .) ]
  ! BEGIN           [ reduce using rule 41 (if1 -> .) ]
  ! IF              [ reduce using rule 41 (if1 -> .) ]
  ! SEMICOLON       [ reduce using rule 41 (if1 -> .) ]
  ! END             [ reduce using rule 41 (if1 -> .) ]
  ! UNTIL           [ reduce using rule 41 (if1 -> .) ]

    procedure_call                 shift and go to state 38
    statement                      shift and go to state 57
    assign_statement               shift and go to state 37
    if_statement                   shift and go to state 39
    while_statement                shift and go to state 40
    repeat_statement               shift and go to state 41
    compound_statement             shift and go to state 42
    if1                            shift and go to state 44
    if2                            shift and go to state 45

state 39

    (31) statement -> if_statement . statement
    (29) statement -> . assign_statement statement
    (30) statement -> . procedure_call statement
    (31) statement -> . if_statement statement
    (32) statement -> . while_statement statement
    (33) statement -> . repeat_statement statement
    (34) statement -> . compound_statement statement
    (35) statement -> .
    (36) assign_statement -> . ID ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> . ID LPARENT expr_list RPARENT SEMICOLON
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (44) while_statement -> . WHILE expr DO statement
    (45) repeat_statement -> . REPEAT statement UNTIL expr
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for END resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for UNTIL resolved using rule 35 (statement -> .)
    SEMICOLON       reduce using rule 35 (statement -> .)
    END             reduce using rule 35 (statement -> .)
    UNTIL           reduce using rule 35 (statement -> .)
    ID              shift and go to state 43
    WHILE           shift and go to state 46
    REPEAT          shift and go to state 47
    BEGIN           shift and go to state 22
    IF              shift and go to state 48

  ! ID              [ reduce using rule 35 (statement -> .) ]
  ! WHILE           [ reduce using rule 35 (statement -> .) ]
  ! REPEAT          [ reduce using rule 35 (statement -> .) ]
  ! BEGIN           [ reduce using rule 35 (statement -> .) ]
  ! IF              [ reduce using rule 35 (statement -> .) ]
  ! ID              [ reduce using rule 41 (if1 -> .) ]
  ! WHILE           [ reduce using rule 41 (if1 -> .) ]
  ! REPEAT          [ reduce using rule 41 (if1 -> .) ]
  ! BEGIN           [ reduce using rule 41 (if1 -> .) ]
  ! IF              [ reduce using rule 41 (if1 -> .) ]
  ! SEMICOLON       [ reduce using rule 41 (if1 -> .) ]
  ! END             [ reduce using rule 41 (if1 -> .) ]
  ! UNTIL           [ reduce using rule 41 (if1 -> .) ]

    if_statement                   shift and go to state 39
    statement                      shift and go to state 58
    assign_statement               shift and go to state 37
    procedure_call                 shift and go to state 38
    while_statement                shift and go to state 40
    repeat_statement               shift and go to state 41
    compound_statement             shift and go to state 42
    if1                            shift and go to state 44
    if2                            shift and go to state 45

state 40

    (32) statement -> while_statement . statement
    (29) statement -> . assign_statement statement
    (30) statement -> . procedure_call statement
    (31) statement -> . if_statement statement
    (32) statement -> . while_statement statement
    (33) statement -> . repeat_statement statement
    (34) statement -> . compound_statement statement
    (35) statement -> .
    (36) assign_statement -> . ID ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> . ID LPARENT expr_list RPARENT SEMICOLON
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (44) while_statement -> . WHILE expr DO statement
    (45) repeat_statement -> . REPEAT statement UNTIL expr
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for END resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for UNTIL resolved using rule 35 (statement -> .)
    SEMICOLON       reduce using rule 35 (statement -> .)
    END             reduce using rule 35 (statement -> .)
    UNTIL           reduce using rule 35 (statement -> .)
    ID              shift and go to state 43
    WHILE           shift and go to state 46
    REPEAT          shift and go to state 47
    BEGIN           shift and go to state 22
    IF              shift and go to state 48

  ! ID              [ reduce using rule 35 (statement -> .) ]
  ! WHILE           [ reduce using rule 35 (statement -> .) ]
  ! REPEAT          [ reduce using rule 35 (statement -> .) ]
  ! BEGIN           [ reduce using rule 35 (statement -> .) ]
  ! IF              [ reduce using rule 35 (statement -> .) ]
  ! ID              [ reduce using rule 41 (if1 -> .) ]
  ! WHILE           [ reduce using rule 41 (if1 -> .) ]
  ! REPEAT          [ reduce using rule 41 (if1 -> .) ]
  ! BEGIN           [ reduce using rule 41 (if1 -> .) ]
  ! IF              [ reduce using rule 41 (if1 -> .) ]
  ! SEMICOLON       [ reduce using rule 41 (if1 -> .) ]
  ! END             [ reduce using rule 41 (if1 -> .) ]
  ! UNTIL           [ reduce using rule 41 (if1 -> .) ]

    while_statement                shift and go to state 40
    statement                      shift and go to state 59
    assign_statement               shift and go to state 37
    procedure_call                 shift and go to state 38
    if_statement                   shift and go to state 39
    repeat_statement               shift and go to state 41
    compound_statement             shift and go to state 42
    if1                            shift and go to state 44
    if2                            shift and go to state 45

state 41

    (33) statement -> repeat_statement . statement
    (29) statement -> . assign_statement statement
    (30) statement -> . procedure_call statement
    (31) statement -> . if_statement statement
    (32) statement -> . while_statement statement
    (33) statement -> . repeat_statement statement
    (34) statement -> . compound_statement statement
    (35) statement -> .
    (36) assign_statement -> . ID ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> . ID LPARENT expr_list RPARENT SEMICOLON
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (44) while_statement -> . WHILE expr DO statement
    (45) repeat_statement -> . REPEAT statement UNTIL expr
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for END resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for UNTIL resolved using rule 35 (statement -> .)
    SEMICOLON       reduce using rule 35 (statement -> .)
    END             reduce using rule 35 (statement -> .)
    UNTIL           reduce using rule 35 (statement -> .)
    ID              shift and go to state 43
    WHILE           shift and go to state 46
    REPEAT          shift and go to state 47
    BEGIN           shift and go to state 22
    IF              shift and go to state 48

  ! ID              [ reduce using rule 35 (statement -> .) ]
  ! WHILE           [ reduce using rule 35 (statement -> .) ]
  ! REPEAT          [ reduce using rule 35 (statement -> .) ]
  ! BEGIN           [ reduce using rule 35 (statement -> .) ]
  ! IF              [ reduce using rule 35 (statement -> .) ]
  ! ID              [ reduce using rule 41 (if1 -> .) ]
  ! WHILE           [ reduce using rule 41 (if1 -> .) ]
  ! REPEAT          [ reduce using rule 41 (if1 -> .) ]
  ! BEGIN           [ reduce using rule 41 (if1 -> .) ]
  ! IF              [ reduce using rule 41 (if1 -> .) ]
  ! SEMICOLON       [ reduce using rule 41 (if1 -> .) ]
  ! END             [ reduce using rule 41 (if1 -> .) ]
  ! UNTIL           [ reduce using rule 41 (if1 -> .) ]

    repeat_statement               shift and go to state 41
    statement                      shift and go to state 60
    assign_statement               shift and go to state 37
    procedure_call                 shift and go to state 38
    if_statement                   shift and go to state 39
    while_statement                shift and go to state 40
    compound_statement             shift and go to state 42
    if1                            shift and go to state 44
    if2                            shift and go to state 45

state 42

    (34) statement -> compound_statement . statement
    (29) statement -> . assign_statement statement
    (30) statement -> . procedure_call statement
    (31) statement -> . if_statement statement
    (32) statement -> . while_statement statement
    (33) statement -> . repeat_statement statement
    (34) statement -> . compound_statement statement
    (35) statement -> .
    (36) assign_statement -> . ID ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> . ID LPARENT expr_list RPARENT SEMICOLON
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (44) while_statement -> . WHILE expr DO statement
    (45) repeat_statement -> . REPEAT statement UNTIL expr
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for END resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for UNTIL resolved using rule 35 (statement -> .)
    SEMICOLON       reduce using rule 35 (statement -> .)
    END             reduce using rule 35 (statement -> .)
    UNTIL           reduce using rule 35 (statement -> .)
    ID              shift and go to state 43
    WHILE           shift and go to state 46
    REPEAT          shift and go to state 47
    BEGIN           shift and go to state 22
    IF              shift and go to state 48

  ! ID              [ reduce using rule 35 (statement -> .) ]
  ! WHILE           [ reduce using rule 35 (statement -> .) ]
  ! REPEAT          [ reduce using rule 35 (statement -> .) ]
  ! BEGIN           [ reduce using rule 35 (statement -> .) ]
  ! IF              [ reduce using rule 35 (statement -> .) ]
  ! ID              [ reduce using rule 41 (if1 -> .) ]
  ! WHILE           [ reduce using rule 41 (if1 -> .) ]
  ! REPEAT          [ reduce using rule 41 (if1 -> .) ]
  ! BEGIN           [ reduce using rule 41 (if1 -> .) ]
  ! IF              [ reduce using rule 41 (if1 -> .) ]
  ! SEMICOLON       [ reduce using rule 41 (if1 -> .) ]
  ! END             [ reduce using rule 41 (if1 -> .) ]
  ! UNTIL           [ reduce using rule 41 (if1 -> .) ]

    compound_statement             shift and go to state 42
    statement                      shift and go to state 61
    assign_statement               shift and go to state 37
    procedure_call                 shift and go to state 38
    if_statement                   shift and go to state 39
    while_statement                shift and go to state 40
    repeat_statement               shift and go to state 41
    if1                            shift and go to state 44
    if2                            shift and go to state 45

state 43

    (36) assign_statement -> ID . ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> ID . LPARENT expr_list RPARENT SEMICOLON

    ASSIGNMENT      shift and go to state 62
    LPARENT         shift and go to state 63


state 44

    (38) if_statement -> if1 .

    ID              reduce using rule 38 (if_statement -> if1 .)
    WHILE           reduce using rule 38 (if_statement -> if1 .)
    REPEAT          reduce using rule 38 (if_statement -> if1 .)
    BEGIN           reduce using rule 38 (if_statement -> if1 .)
    IF              reduce using rule 38 (if_statement -> if1 .)
    SEMICOLON       reduce using rule 38 (if_statement -> if1 .)
    END             reduce using rule 38 (if_statement -> if1 .)
    UNTIL           reduce using rule 38 (if_statement -> if1 .)


state 45

    (39) if_statement -> if2 .

    ID              reduce using rule 39 (if_statement -> if2 .)
    WHILE           reduce using rule 39 (if_statement -> if2 .)
    REPEAT          reduce using rule 39 (if_statement -> if2 .)
    BEGIN           reduce using rule 39 (if_statement -> if2 .)
    IF              reduce using rule 39 (if_statement -> if2 .)
    SEMICOLON       reduce using rule 39 (if_statement -> if2 .)
    END             reduce using rule 39 (if_statement -> if2 .)
    UNTIL           reduce using rule 39 (if_statement -> if2 .)


state 46

    (44) while_statement -> WHILE . expr DO statement
    (48) expr -> . simple_expr relop_simple_expr
    (57) simple_expr -> . uplus_uminus factor
    (58) simple_expr -> . uplus_uminus factor addop_mulop factor simple_expr
    (59) uplus_uminus -> . UPLUS
    (60) uplus_uminus -> . UMINUS
    (61) uplus_uminus -> .

  ! shift/reduce conflict for UPLUS resolved as shift
  ! shift/reduce conflict for UMINUS resolved as shift
    UPLUS           shift and go to state 67
    UMINUS          shift and go to state 68
    ID              reduce using rule 61 (uplus_uminus -> .)
    INTEGER         reduce using rule 61 (uplus_uminus -> .)
    REAL            reduce using rule 61 (uplus_uminus -> .)
    STRING          reduce using rule 61 (uplus_uminus -> .)
    NOT             reduce using rule 61 (uplus_uminus -> .)
    PLUS            reduce using rule 61 (uplus_uminus -> .)
    MINUS           reduce using rule 61 (uplus_uminus -> .)
    OR              reduce using rule 61 (uplus_uminus -> .)
    TIMES           reduce using rule 61 (uplus_uminus -> .)
    DIVIDE          reduce using rule 61 (uplus_uminus -> .)
    DIV             reduce using rule 61 (uplus_uminus -> .)
    MOD             reduce using rule 61 (uplus_uminus -> .)
    AND             reduce using rule 61 (uplus_uminus -> .)
    EQUALS          reduce using rule 61 (uplus_uminus -> .)
    LTHAN           reduce using rule 61 (uplus_uminus -> .)
    GTHAN           reduce using rule 61 (uplus_uminus -> .)
    DIFFERENT       reduce using rule 61 (uplus_uminus -> .)
    GEQUALS         reduce using rule 61 (uplus_uminus -> .)
    LEQUALS         reduce using rule 61 (uplus_uminus -> .)
    DO              reduce using rule 61 (uplus_uminus -> .)

  ! UPLUS           [ reduce using rule 61 (uplus_uminus -> .) ]
  ! UMINUS          [ reduce using rule 61 (uplus_uminus -> .) ]

    expr                           shift and go to state 64
    simple_expr                    shift and go to state 65
    uplus_uminus                   shift and go to state 66

state 47

    (45) repeat_statement -> REPEAT . statement UNTIL expr
    (29) statement -> . assign_statement statement
    (30) statement -> . procedure_call statement
    (31) statement -> . if_statement statement
    (32) statement -> . while_statement statement
    (33) statement -> . repeat_statement statement
    (34) statement -> . compound_statement statement
    (35) statement -> .
    (36) assign_statement -> . ID ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> . ID LPARENT expr_list RPARENT SEMICOLON
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (44) while_statement -> . WHILE expr DO statement
    (45) repeat_statement -> . REPEAT statement UNTIL expr
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for UNTIL resolved using rule 35 (statement -> .)
    UNTIL           reduce using rule 35 (statement -> .)
    ID              shift and go to state 43
    WHILE           shift and go to state 46
    REPEAT          shift and go to state 47
    BEGIN           shift and go to state 22
    IF              shift and go to state 48

  ! ID              [ reduce using rule 41 (if1 -> .) ]
  ! WHILE           [ reduce using rule 41 (if1 -> .) ]
  ! REPEAT          [ reduce using rule 41 (if1 -> .) ]
  ! BEGIN           [ reduce using rule 41 (if1 -> .) ]
  ! IF              [ reduce using rule 41 (if1 -> .) ]
  ! UNTIL           [ reduce using rule 41 (if1 -> .) ]

    statement                      shift and go to state 69
    assign_statement               shift and go to state 37
    procedure_call                 shift and go to state 38
    if_statement                   shift and go to state 39
    while_statement                shift and go to state 40
    repeat_statement               shift and go to state 41
    compound_statement             shift and go to state 42
    if1                            shift and go to state 44
    if2                            shift and go to state 45

state 48

    (40) if1 -> IF . expr_list THEN if1 ELSE if1
    (42) if2 -> IF . expr_list THEN if_statement
    (43) if2 -> IF . expr_list THEN if1 ELSE if2
    (46) expr_list -> . expr
    (47) expr_list -> . expr COMMA expr_list
    (48) expr -> . simple_expr relop_simple_expr
    (57) simple_expr -> . uplus_uminus factor
    (58) simple_expr -> . uplus_uminus factor addop_mulop factor simple_expr
    (59) uplus_uminus -> . UPLUS
    (60) uplus_uminus -> . UMINUS
    (61) uplus_uminus -> .

  ! shift/reduce conflict for UPLUS resolved as shift
  ! shift/reduce conflict for UMINUS resolved as shift
    UPLUS           shift and go to state 67
    UMINUS          shift and go to state 68
    ID              reduce using rule 61 (uplus_uminus -> .)
    INTEGER         reduce using rule 61 (uplus_uminus -> .)
    REAL            reduce using rule 61 (uplus_uminus -> .)
    STRING          reduce using rule 61 (uplus_uminus -> .)
    NOT             reduce using rule 61 (uplus_uminus -> .)
    PLUS            reduce using rule 61 (uplus_uminus -> .)
    MINUS           reduce using rule 61 (uplus_uminus -> .)
    OR              reduce using rule 61 (uplus_uminus -> .)
    TIMES           reduce using rule 61 (uplus_uminus -> .)
    DIVIDE          reduce using rule 61 (uplus_uminus -> .)
    DIV             reduce using rule 61 (uplus_uminus -> .)
    MOD             reduce using rule 61 (uplus_uminus -> .)
    AND             reduce using rule 61 (uplus_uminus -> .)
    EQUALS          reduce using rule 61 (uplus_uminus -> .)
    LTHAN           reduce using rule 61 (uplus_uminus -> .)
    GTHAN           reduce using rule 61 (uplus_uminus -> .)
    DIFFERENT       reduce using rule 61 (uplus_uminus -> .)
    GEQUALS         reduce using rule 61 (uplus_uminus -> .)
    LEQUALS         reduce using rule 61 (uplus_uminus -> .)
    COMMA           reduce using rule 61 (uplus_uminus -> .)
    THEN            reduce using rule 61 (uplus_uminus -> .)

  ! UPLUS           [ reduce using rule 61 (uplus_uminus -> .) ]
  ! UMINUS          [ reduce using rule 61 (uplus_uminus -> .) ]

    expr_list                      shift and go to state 70
    expr                           shift and go to state 71
    simple_expr                    shift and go to state 65
    uplus_uminus                   shift and go to state 66

state 49

    (23) procedure_declaration -> PROCEDURE ID LPARENT . param_section RPARENT SEMICOLON
    (25) param_section -> . identifier_list TWOPOINTS types SEMICOLON param_section
    (26) param_section -> .
    (18) identifier_list -> . ID
    (19) identifier_list -> . ID COMMA identifier_list

    RPARENT         reduce using rule 26 (param_section -> .)
    ID              shift and go to state 19

    param_section                  shift and go to state 72
    identifier_list                shift and go to state 73

state 50

    (24) function_declaration -> FUNCTION ID LPARENT . param_section RPARENT TWOPOINTS types SEMICOLON
    (25) param_section -> . identifier_list TWOPOINTS types SEMICOLON param_section
    (26) param_section -> .
    (18) identifier_list -> . ID
    (19) identifier_list -> . ID COMMA identifier_list

    RPARENT         reduce using rule 26 (param_section -> .)
    ID              shift and go to state 19

    param_section                  shift and go to state 74
    identifier_list                shift and go to state 73

state 51

    (10) var_declaration -> identifier_list TWOPOINTS types . SEMICOLON var_declaration
    (11) var_declaration -> identifier_list TWOPOINTS types . SEMICOLON

    SEMICOLON       shift and go to state 75


state 52

    (19) identifier_list -> ID COMMA identifier_list .

    TWOPOINTS       reduce using rule 19 (identifier_list -> ID COMMA identifier_list .)


state 53

    (6) const_definition -> ID EQUALS types SEMICOLON . const_definition
    (7) const_definition -> ID EQUALS types SEMICOLON .
    (6) const_definition -> . ID EQUALS types SEMICOLON const_definition
    (7) const_definition -> . ID EQUALS types SEMICOLON

    VAR             reduce using rule 7 (const_definition -> ID EQUALS types SEMICOLON .)
    PROCEDURE       reduce using rule 7 (const_definition -> ID EQUALS types SEMICOLON .)
    FUNCTION        reduce using rule 7 (const_definition -> ID EQUALS types SEMICOLON .)
    BEGIN           reduce using rule 7 (const_definition -> ID EQUALS types SEMICOLON .)
    ID              shift and go to state 11

    const_definition               shift and go to state 76

state 54

    (27) compound_statement -> BEGIN statement SEMICOLON . statement END SEMICOLON
    (29) statement -> . assign_statement statement
    (30) statement -> . procedure_call statement
    (31) statement -> . if_statement statement
    (32) statement -> . while_statement statement
    (33) statement -> . repeat_statement statement
    (34) statement -> . compound_statement statement
    (35) statement -> .
    (36) assign_statement -> . ID ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> . ID LPARENT expr_list RPARENT SEMICOLON
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (44) while_statement -> . WHILE expr DO statement
    (45) repeat_statement -> . REPEAT statement UNTIL expr
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for END resolved using rule 35 (statement -> .)
    END             reduce using rule 35 (statement -> .)
    ID              shift and go to state 43
    WHILE           shift and go to state 46
    REPEAT          shift and go to state 47
    BEGIN           shift and go to state 22
    IF              shift and go to state 48

  ! ID              [ reduce using rule 41 (if1 -> .) ]
  ! WHILE           [ reduce using rule 41 (if1 -> .) ]
  ! REPEAT          [ reduce using rule 41 (if1 -> .) ]
  ! BEGIN           [ reduce using rule 41 (if1 -> .) ]
  ! IF              [ reduce using rule 41 (if1 -> .) ]
  ! END             [ reduce using rule 41 (if1 -> .) ]

    statement                      shift and go to state 77
    assign_statement               shift and go to state 37
    procedure_call                 shift and go to state 38
    if_statement                   shift and go to state 39
    while_statement                shift and go to state 40
    repeat_statement               shift and go to state 41
    compound_statement             shift and go to state 42
    if1                            shift and go to state 44
    if2                            shift and go to state 45

state 55

    (28) compound_statement -> BEGIN statement END . SEMICOLON

    SEMICOLON       shift and go to state 78


state 56

    (29) statement -> assign_statement statement .

    SEMICOLON       reduce using rule 29 (statement -> assign_statement statement .)
    END             reduce using rule 29 (statement -> assign_statement statement .)
    UNTIL           reduce using rule 29 (statement -> assign_statement statement .)
    ID              reduce using rule 29 (statement -> assign_statement statement .)
    WHILE           reduce using rule 29 (statement -> assign_statement statement .)
    REPEAT          reduce using rule 29 (statement -> assign_statement statement .)
    BEGIN           reduce using rule 29 (statement -> assign_statement statement .)
    IF              reduce using rule 29 (statement -> assign_statement statement .)


state 57

    (30) statement -> procedure_call statement .

    SEMICOLON       reduce using rule 30 (statement -> procedure_call statement .)
    END             reduce using rule 30 (statement -> procedure_call statement .)
    UNTIL           reduce using rule 30 (statement -> procedure_call statement .)
    ID              reduce using rule 30 (statement -> procedure_call statement .)
    WHILE           reduce using rule 30 (statement -> procedure_call statement .)
    REPEAT          reduce using rule 30 (statement -> procedure_call statement .)
    BEGIN           reduce using rule 30 (statement -> procedure_call statement .)
    IF              reduce using rule 30 (statement -> procedure_call statement .)


state 58

    (31) statement -> if_statement statement .

    SEMICOLON       reduce using rule 31 (statement -> if_statement statement .)
    END             reduce using rule 31 (statement -> if_statement statement .)
    UNTIL           reduce using rule 31 (statement -> if_statement statement .)
    ID              reduce using rule 31 (statement -> if_statement statement .)
    WHILE           reduce using rule 31 (statement -> if_statement statement .)
    REPEAT          reduce using rule 31 (statement -> if_statement statement .)
    BEGIN           reduce using rule 31 (statement -> if_statement statement .)
    IF              reduce using rule 31 (statement -> if_statement statement .)


state 59

    (32) statement -> while_statement statement .

    SEMICOLON       reduce using rule 32 (statement -> while_statement statement .)
    END             reduce using rule 32 (statement -> while_statement statement .)
    UNTIL           reduce using rule 32 (statement -> while_statement statement .)
    ID              reduce using rule 32 (statement -> while_statement statement .)
    WHILE           reduce using rule 32 (statement -> while_statement statement .)
    REPEAT          reduce using rule 32 (statement -> while_statement statement .)
    BEGIN           reduce using rule 32 (statement -> while_statement statement .)
    IF              reduce using rule 32 (statement -> while_statement statement .)


state 60

    (33) statement -> repeat_statement statement .

    SEMICOLON       reduce using rule 33 (statement -> repeat_statement statement .)
    END             reduce using rule 33 (statement -> repeat_statement statement .)
    UNTIL           reduce using rule 33 (statement -> repeat_statement statement .)
    ID              reduce using rule 33 (statement -> repeat_statement statement .)
    WHILE           reduce using rule 33 (statement -> repeat_statement statement .)
    REPEAT          reduce using rule 33 (statement -> repeat_statement statement .)
    BEGIN           reduce using rule 33 (statement -> repeat_statement statement .)
    IF              reduce using rule 33 (statement -> repeat_statement statement .)


state 61

    (34) statement -> compound_statement statement .

    SEMICOLON       reduce using rule 34 (statement -> compound_statement statement .)
    END             reduce using rule 34 (statement -> compound_statement statement .)
    UNTIL           reduce using rule 34 (statement -> compound_statement statement .)
    ID              reduce using rule 34 (statement -> compound_statement statement .)
    WHILE           reduce using rule 34 (statement -> compound_statement statement .)
    REPEAT          reduce using rule 34 (statement -> compound_statement statement .)
    BEGIN           reduce using rule 34 (statement -> compound_statement statement .)
    IF              reduce using rule 34 (statement -> compound_statement statement .)


state 62

    (36) assign_statement -> ID ASSIGNMENT . expr SEMICOLON
    (48) expr -> . simple_expr relop_simple_expr
    (57) simple_expr -> . uplus_uminus factor
    (58) simple_expr -> . uplus_uminus factor addop_mulop factor simple_expr
    (59) uplus_uminus -> . UPLUS
    (60) uplus_uminus -> . UMINUS
    (61) uplus_uminus -> .

  ! shift/reduce conflict for UPLUS resolved as shift
  ! shift/reduce conflict for UMINUS resolved as shift
    UPLUS           shift and go to state 67
    UMINUS          shift and go to state 68
    ID              reduce using rule 61 (uplus_uminus -> .)
    INTEGER         reduce using rule 61 (uplus_uminus -> .)
    REAL            reduce using rule 61 (uplus_uminus -> .)
    STRING          reduce using rule 61 (uplus_uminus -> .)
    NOT             reduce using rule 61 (uplus_uminus -> .)
    PLUS            reduce using rule 61 (uplus_uminus -> .)
    MINUS           reduce using rule 61 (uplus_uminus -> .)
    OR              reduce using rule 61 (uplus_uminus -> .)
    TIMES           reduce using rule 61 (uplus_uminus -> .)
    DIVIDE          reduce using rule 61 (uplus_uminus -> .)
    DIV             reduce using rule 61 (uplus_uminus -> .)
    MOD             reduce using rule 61 (uplus_uminus -> .)
    AND             reduce using rule 61 (uplus_uminus -> .)
    EQUALS          reduce using rule 61 (uplus_uminus -> .)
    LTHAN           reduce using rule 61 (uplus_uminus -> .)
    GTHAN           reduce using rule 61 (uplus_uminus -> .)
    DIFFERENT       reduce using rule 61 (uplus_uminus -> .)
    GEQUALS         reduce using rule 61 (uplus_uminus -> .)
    LEQUALS         reduce using rule 61 (uplus_uminus -> .)
    SEMICOLON       reduce using rule 61 (uplus_uminus -> .)

  ! UPLUS           [ reduce using rule 61 (uplus_uminus -> .) ]
  ! UMINUS          [ reduce using rule 61 (uplus_uminus -> .) ]

    expr                           shift and go to state 79
    simple_expr                    shift and go to state 65
    uplus_uminus                   shift and go to state 66

state 63

    (37) procedure_call -> ID LPARENT . expr_list RPARENT SEMICOLON
    (46) expr_list -> . expr
    (47) expr_list -> . expr COMMA expr_list
    (48) expr -> . simple_expr relop_simple_expr
    (57) simple_expr -> . uplus_uminus factor
    (58) simple_expr -> . uplus_uminus factor addop_mulop factor simple_expr
    (59) uplus_uminus -> . UPLUS
    (60) uplus_uminus -> . UMINUS
    (61) uplus_uminus -> .

  ! shift/reduce conflict for UPLUS resolved as shift
  ! shift/reduce conflict for UMINUS resolved as shift
    UPLUS           shift and go to state 67
    UMINUS          shift and go to state 68
    ID              reduce using rule 61 (uplus_uminus -> .)
    INTEGER         reduce using rule 61 (uplus_uminus -> .)
    REAL            reduce using rule 61 (uplus_uminus -> .)
    STRING          reduce using rule 61 (uplus_uminus -> .)
    NOT             reduce using rule 61 (uplus_uminus -> .)
    PLUS            reduce using rule 61 (uplus_uminus -> .)
    MINUS           reduce using rule 61 (uplus_uminus -> .)
    OR              reduce using rule 61 (uplus_uminus -> .)
    TIMES           reduce using rule 61 (uplus_uminus -> .)
    DIVIDE          reduce using rule 61 (uplus_uminus -> .)
    DIV             reduce using rule 61 (uplus_uminus -> .)
    MOD             reduce using rule 61 (uplus_uminus -> .)
    AND             reduce using rule 61 (uplus_uminus -> .)
    EQUALS          reduce using rule 61 (uplus_uminus -> .)
    LTHAN           reduce using rule 61 (uplus_uminus -> .)
    GTHAN           reduce using rule 61 (uplus_uminus -> .)
    DIFFERENT       reduce using rule 61 (uplus_uminus -> .)
    GEQUALS         reduce using rule 61 (uplus_uminus -> .)
    LEQUALS         reduce using rule 61 (uplus_uminus -> .)
    COMMA           reduce using rule 61 (uplus_uminus -> .)
    RPARENT         reduce using rule 61 (uplus_uminus -> .)

  ! UPLUS           [ reduce using rule 61 (uplus_uminus -> .) ]
  ! UMINUS          [ reduce using rule 61 (uplus_uminus -> .) ]

    expr_list                      shift and go to state 80
    expr                           shift and go to state 71
    simple_expr                    shift and go to state 65
    uplus_uminus                   shift and go to state 66

state 64

    (44) while_statement -> WHILE expr . DO statement

    DO              shift and go to state 81


state 65

    (48) expr -> simple_expr . relop_simple_expr
    (49) relop_simple_expr -> . relop simple_expr relop_simple_expr
    (50) relop_simple_expr -> .
    (51) relop -> . EQUALS
    (52) relop -> . LTHAN
    (53) relop -> . GTHAN
    (54) relop -> . DIFFERENT
    (55) relop -> . GEQUALS
    (56) relop -> . LEQUALS

    DO              reduce using rule 50 (relop_simple_expr -> .)
    COMMA           reduce using rule 50 (relop_simple_expr -> .)
    THEN            reduce using rule 50 (relop_simple_expr -> .)
    SEMICOLON       reduce using rule 50 (relop_simple_expr -> .)
    RPARENT         reduce using rule 50 (relop_simple_expr -> .)
    ID              reduce using rule 50 (relop_simple_expr -> .)
    WHILE           reduce using rule 50 (relop_simple_expr -> .)
    REPEAT          reduce using rule 50 (relop_simple_expr -> .)
    BEGIN           reduce using rule 50 (relop_simple_expr -> .)
    IF              reduce using rule 50 (relop_simple_expr -> .)
    END             reduce using rule 50 (relop_simple_expr -> .)
    UNTIL           reduce using rule 50 (relop_simple_expr -> .)
    EQUALS          shift and go to state 84
    LTHAN           shift and go to state 85
    GTHAN           shift and go to state 86
    DIFFERENT       shift and go to state 87
    GEQUALS         shift and go to state 88
    LEQUALS         shift and go to state 89

    relop_simple_expr              shift and go to state 82
    relop                          shift and go to state 83

state 66

    (57) simple_expr -> uplus_uminus . factor
    (58) simple_expr -> uplus_uminus . factor addop_mulop factor simple_expr
    (71) factor -> . ID
    (72) factor -> . INTEGER
    (73) factor -> . REAL
    (74) factor -> . STRING
    (75) factor -> . NOT factor
    (76) factor -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    ID              shift and go to state 91
    INTEGER         shift and go to state 92
    REAL            shift and go to state 93
    STRING          shift and go to state 94
    NOT             shift and go to state 95
    PLUS            reduce using rule 76 (factor -> .)
    MINUS           reduce using rule 76 (factor -> .)
    OR              reduce using rule 76 (factor -> .)
    TIMES           reduce using rule 76 (factor -> .)
    DIVIDE          reduce using rule 76 (factor -> .)
    DIV             reduce using rule 76 (factor -> .)
    MOD             reduce using rule 76 (factor -> .)
    AND             reduce using rule 76 (factor -> .)
    UPLUS           reduce using rule 76 (factor -> .)
    UMINUS          reduce using rule 76 (factor -> .)
    EQUALS          reduce using rule 76 (factor -> .)
    LTHAN           reduce using rule 76 (factor -> .)
    GTHAN           reduce using rule 76 (factor -> .)
    DIFFERENT       reduce using rule 76 (factor -> .)
    GEQUALS         reduce using rule 76 (factor -> .)
    LEQUALS         reduce using rule 76 (factor -> .)
    DO              reduce using rule 76 (factor -> .)
    COMMA           reduce using rule 76 (factor -> .)
    THEN            reduce using rule 76 (factor -> .)
    SEMICOLON       reduce using rule 76 (factor -> .)
    RPARENT         reduce using rule 76 (factor -> .)
    WHILE           reduce using rule 76 (factor -> .)
    REPEAT          reduce using rule 76 (factor -> .)
    BEGIN           reduce using rule 76 (factor -> .)
    IF              reduce using rule 76 (factor -> .)
    END             reduce using rule 76 (factor -> .)
    UNTIL           reduce using rule 76 (factor -> .)

  ! ID              [ reduce using rule 76 (factor -> .) ]
  ! INTEGER         [ reduce using rule 76 (factor -> .) ]
  ! REAL            [ reduce using rule 76 (factor -> .) ]
  ! STRING          [ reduce using rule 76 (factor -> .) ]
  ! NOT             [ reduce using rule 76 (factor -> .) ]

    factor                         shift and go to state 90

state 67

    (59) uplus_uminus -> UPLUS .

    ID              reduce using rule 59 (uplus_uminus -> UPLUS .)
    INTEGER         reduce using rule 59 (uplus_uminus -> UPLUS .)
    REAL            reduce using rule 59 (uplus_uminus -> UPLUS .)
    STRING          reduce using rule 59 (uplus_uminus -> UPLUS .)
    NOT             reduce using rule 59 (uplus_uminus -> UPLUS .)
    PLUS            reduce using rule 59 (uplus_uminus -> UPLUS .)
    MINUS           reduce using rule 59 (uplus_uminus -> UPLUS .)
    OR              reduce using rule 59 (uplus_uminus -> UPLUS .)
    TIMES           reduce using rule 59 (uplus_uminus -> UPLUS .)
    DIVIDE          reduce using rule 59 (uplus_uminus -> UPLUS .)
    DIV             reduce using rule 59 (uplus_uminus -> UPLUS .)
    MOD             reduce using rule 59 (uplus_uminus -> UPLUS .)
    AND             reduce using rule 59 (uplus_uminus -> UPLUS .)
    UPLUS           reduce using rule 59 (uplus_uminus -> UPLUS .)
    UMINUS          reduce using rule 59 (uplus_uminus -> UPLUS .)
    EQUALS          reduce using rule 59 (uplus_uminus -> UPLUS .)
    LTHAN           reduce using rule 59 (uplus_uminus -> UPLUS .)
    GTHAN           reduce using rule 59 (uplus_uminus -> UPLUS .)
    DIFFERENT       reduce using rule 59 (uplus_uminus -> UPLUS .)
    GEQUALS         reduce using rule 59 (uplus_uminus -> UPLUS .)
    LEQUALS         reduce using rule 59 (uplus_uminus -> UPLUS .)
    DO              reduce using rule 59 (uplus_uminus -> UPLUS .)
    COMMA           reduce using rule 59 (uplus_uminus -> UPLUS .)
    THEN            reduce using rule 59 (uplus_uminus -> UPLUS .)
    SEMICOLON       reduce using rule 59 (uplus_uminus -> UPLUS .)
    RPARENT         reduce using rule 59 (uplus_uminus -> UPLUS .)
    WHILE           reduce using rule 59 (uplus_uminus -> UPLUS .)
    REPEAT          reduce using rule 59 (uplus_uminus -> UPLUS .)
    BEGIN           reduce using rule 59 (uplus_uminus -> UPLUS .)
    IF              reduce using rule 59 (uplus_uminus -> UPLUS .)
    END             reduce using rule 59 (uplus_uminus -> UPLUS .)
    UNTIL           reduce using rule 59 (uplus_uminus -> UPLUS .)


state 68

    (60) uplus_uminus -> UMINUS .

    ID              reduce using rule 60 (uplus_uminus -> UMINUS .)
    INTEGER         reduce using rule 60 (uplus_uminus -> UMINUS .)
    REAL            reduce using rule 60 (uplus_uminus -> UMINUS .)
    STRING          reduce using rule 60 (uplus_uminus -> UMINUS .)
    NOT             reduce using rule 60 (uplus_uminus -> UMINUS .)
    PLUS            reduce using rule 60 (uplus_uminus -> UMINUS .)
    MINUS           reduce using rule 60 (uplus_uminus -> UMINUS .)
    OR              reduce using rule 60 (uplus_uminus -> UMINUS .)
    TIMES           reduce using rule 60 (uplus_uminus -> UMINUS .)
    DIVIDE          reduce using rule 60 (uplus_uminus -> UMINUS .)
    DIV             reduce using rule 60 (uplus_uminus -> UMINUS .)
    MOD             reduce using rule 60 (uplus_uminus -> UMINUS .)
    AND             reduce using rule 60 (uplus_uminus -> UMINUS .)
    UPLUS           reduce using rule 60 (uplus_uminus -> UMINUS .)
    UMINUS          reduce using rule 60 (uplus_uminus -> UMINUS .)
    EQUALS          reduce using rule 60 (uplus_uminus -> UMINUS .)
    LTHAN           reduce using rule 60 (uplus_uminus -> UMINUS .)
    GTHAN           reduce using rule 60 (uplus_uminus -> UMINUS .)
    DIFFERENT       reduce using rule 60 (uplus_uminus -> UMINUS .)
    GEQUALS         reduce using rule 60 (uplus_uminus -> UMINUS .)
    LEQUALS         reduce using rule 60 (uplus_uminus -> UMINUS .)
    DO              reduce using rule 60 (uplus_uminus -> UMINUS .)
    COMMA           reduce using rule 60 (uplus_uminus -> UMINUS .)
    THEN            reduce using rule 60 (uplus_uminus -> UMINUS .)
    SEMICOLON       reduce using rule 60 (uplus_uminus -> UMINUS .)
    RPARENT         reduce using rule 60 (uplus_uminus -> UMINUS .)
    WHILE           reduce using rule 60 (uplus_uminus -> UMINUS .)
    REPEAT          reduce using rule 60 (uplus_uminus -> UMINUS .)
    BEGIN           reduce using rule 60 (uplus_uminus -> UMINUS .)
    IF              reduce using rule 60 (uplus_uminus -> UMINUS .)
    END             reduce using rule 60 (uplus_uminus -> UMINUS .)
    UNTIL           reduce using rule 60 (uplus_uminus -> UMINUS .)


state 69

    (45) repeat_statement -> REPEAT statement . UNTIL expr

    UNTIL           shift and go to state 96


state 70

    (40) if1 -> IF expr_list . THEN if1 ELSE if1
    (42) if2 -> IF expr_list . THEN if_statement
    (43) if2 -> IF expr_list . THEN if1 ELSE if2

    THEN            shift and go to state 97


state 71

    (46) expr_list -> expr .
    (47) expr_list -> expr . COMMA expr_list

    THEN            reduce using rule 46 (expr_list -> expr .)
    RPARENT         reduce using rule 46 (expr_list -> expr .)
    COMMA           shift and go to state 98


state 72

    (23) procedure_declaration -> PROCEDURE ID LPARENT param_section . RPARENT SEMICOLON

    RPARENT         shift and go to state 99


state 73

    (25) param_section -> identifier_list . TWOPOINTS types SEMICOLON param_section

    TWOPOINTS       shift and go to state 100


state 74

    (24) function_declaration -> FUNCTION ID LPARENT param_section . RPARENT TWOPOINTS types SEMICOLON

    RPARENT         shift and go to state 101


state 75

    (10) var_declaration -> identifier_list TWOPOINTS types SEMICOLON . var_declaration
    (11) var_declaration -> identifier_list TWOPOINTS types SEMICOLON .
    (10) var_declaration -> . identifier_list TWOPOINTS types SEMICOLON var_declaration
    (11) var_declaration -> . identifier_list TWOPOINTS types SEMICOLON
    (18) identifier_list -> . ID
    (19) identifier_list -> . ID COMMA identifier_list

    PROCEDURE       reduce using rule 11 (var_declaration -> identifier_list TWOPOINTS types SEMICOLON .)
    FUNCTION        reduce using rule 11 (var_declaration -> identifier_list TWOPOINTS types SEMICOLON .)
    BEGIN           reduce using rule 11 (var_declaration -> identifier_list TWOPOINTS types SEMICOLON .)
    ID              shift and go to state 19

    identifier_list                shift and go to state 18
    var_declaration                shift and go to state 102

state 76

    (6) const_definition -> ID EQUALS types SEMICOLON const_definition .

    VAR             reduce using rule 6 (const_definition -> ID EQUALS types SEMICOLON const_definition .)
    PROCEDURE       reduce using rule 6 (const_definition -> ID EQUALS types SEMICOLON const_definition .)
    FUNCTION        reduce using rule 6 (const_definition -> ID EQUALS types SEMICOLON const_definition .)
    BEGIN           reduce using rule 6 (const_definition -> ID EQUALS types SEMICOLON const_definition .)


state 77

    (27) compound_statement -> BEGIN statement SEMICOLON statement . END SEMICOLON

    END             shift and go to state 103


state 78

    (28) compound_statement -> BEGIN statement END SEMICOLON .

    $end            reduce using rule 28 (compound_statement -> BEGIN statement END SEMICOLON .)
    ID              reduce using rule 28 (compound_statement -> BEGIN statement END SEMICOLON .)
    WHILE           reduce using rule 28 (compound_statement -> BEGIN statement END SEMICOLON .)
    REPEAT          reduce using rule 28 (compound_statement -> BEGIN statement END SEMICOLON .)
    BEGIN           reduce using rule 28 (compound_statement -> BEGIN statement END SEMICOLON .)
    IF              reduce using rule 28 (compound_statement -> BEGIN statement END SEMICOLON .)
    SEMICOLON       reduce using rule 28 (compound_statement -> BEGIN statement END SEMICOLON .)
    END             reduce using rule 28 (compound_statement -> BEGIN statement END SEMICOLON .)
    UNTIL           reduce using rule 28 (compound_statement -> BEGIN statement END SEMICOLON .)


state 79

    (36) assign_statement -> ID ASSIGNMENT expr . SEMICOLON

    SEMICOLON       shift and go to state 104


state 80

    (37) procedure_call -> ID LPARENT expr_list . RPARENT SEMICOLON

    RPARENT         shift and go to state 105


state 81

    (44) while_statement -> WHILE expr DO . statement
    (29) statement -> . assign_statement statement
    (30) statement -> . procedure_call statement
    (31) statement -> . if_statement statement
    (32) statement -> . while_statement statement
    (33) statement -> . repeat_statement statement
    (34) statement -> . compound_statement statement
    (35) statement -> .
    (36) assign_statement -> . ID ASSIGNMENT expr SEMICOLON
    (37) procedure_call -> . ID LPARENT expr_list RPARENT SEMICOLON
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (44) while_statement -> . WHILE expr DO statement
    (45) repeat_statement -> . REPEAT statement UNTIL expr
    (27) compound_statement -> . BEGIN statement SEMICOLON statement END SEMICOLON
    (28) compound_statement -> . BEGIN statement END SEMICOLON
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for REPEAT resolved as shift
  ! shift/reduce conflict for BEGIN resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! reduce/reduce conflict for SEMICOLON resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for END resolved using rule 35 (statement -> .)
  ! reduce/reduce conflict for UNTIL resolved using rule 35 (statement -> .)
    SEMICOLON       reduce using rule 35 (statement -> .)
    END             reduce using rule 35 (statement -> .)
    UNTIL           reduce using rule 35 (statement -> .)
    ID              shift and go to state 43
    WHILE           shift and go to state 46
    REPEAT          shift and go to state 47
    BEGIN           shift and go to state 22
    IF              shift and go to state 48

  ! ID              [ reduce using rule 35 (statement -> .) ]
  ! WHILE           [ reduce using rule 35 (statement -> .) ]
  ! REPEAT          [ reduce using rule 35 (statement -> .) ]
  ! BEGIN           [ reduce using rule 35 (statement -> .) ]
  ! IF              [ reduce using rule 35 (statement -> .) ]
  ! ID              [ reduce using rule 41 (if1 -> .) ]
  ! WHILE           [ reduce using rule 41 (if1 -> .) ]
  ! REPEAT          [ reduce using rule 41 (if1 -> .) ]
  ! BEGIN           [ reduce using rule 41 (if1 -> .) ]
  ! IF              [ reduce using rule 41 (if1 -> .) ]
  ! SEMICOLON       [ reduce using rule 41 (if1 -> .) ]
  ! END             [ reduce using rule 41 (if1 -> .) ]
  ! UNTIL           [ reduce using rule 41 (if1 -> .) ]

    statement                      shift and go to state 106
    assign_statement               shift and go to state 37
    procedure_call                 shift and go to state 38
    if_statement                   shift and go to state 39
    while_statement                shift and go to state 40
    repeat_statement               shift and go to state 41
    compound_statement             shift and go to state 42
    if1                            shift and go to state 44
    if2                            shift and go to state 45

state 82

    (48) expr -> simple_expr relop_simple_expr .

    DO              reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    COMMA           reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    THEN            reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    SEMICOLON       reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    RPARENT         reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    ID              reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    WHILE           reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    REPEAT          reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    BEGIN           reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    IF              reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    END             reduce using rule 48 (expr -> simple_expr relop_simple_expr .)
    UNTIL           reduce using rule 48 (expr -> simple_expr relop_simple_expr .)


state 83

    (49) relop_simple_expr -> relop . simple_expr relop_simple_expr
    (57) simple_expr -> . uplus_uminus factor
    (58) simple_expr -> . uplus_uminus factor addop_mulop factor simple_expr
    (59) uplus_uminus -> . UPLUS
    (60) uplus_uminus -> . UMINUS
    (61) uplus_uminus -> .

  ! shift/reduce conflict for UPLUS resolved as shift
  ! shift/reduce conflict for UMINUS resolved as shift
    UPLUS           shift and go to state 67
    UMINUS          shift and go to state 68
    ID              reduce using rule 61 (uplus_uminus -> .)
    INTEGER         reduce using rule 61 (uplus_uminus -> .)
    REAL            reduce using rule 61 (uplus_uminus -> .)
    STRING          reduce using rule 61 (uplus_uminus -> .)
    NOT             reduce using rule 61 (uplus_uminus -> .)
    PLUS            reduce using rule 61 (uplus_uminus -> .)
    MINUS           reduce using rule 61 (uplus_uminus -> .)
    OR              reduce using rule 61 (uplus_uminus -> .)
    TIMES           reduce using rule 61 (uplus_uminus -> .)
    DIVIDE          reduce using rule 61 (uplus_uminus -> .)
    DIV             reduce using rule 61 (uplus_uminus -> .)
    MOD             reduce using rule 61 (uplus_uminus -> .)
    AND             reduce using rule 61 (uplus_uminus -> .)
    EQUALS          reduce using rule 61 (uplus_uminus -> .)
    LTHAN           reduce using rule 61 (uplus_uminus -> .)
    GTHAN           reduce using rule 61 (uplus_uminus -> .)
    DIFFERENT       reduce using rule 61 (uplus_uminus -> .)
    GEQUALS         reduce using rule 61 (uplus_uminus -> .)
    LEQUALS         reduce using rule 61 (uplus_uminus -> .)
    DO              reduce using rule 61 (uplus_uminus -> .)
    COMMA           reduce using rule 61 (uplus_uminus -> .)
    THEN            reduce using rule 61 (uplus_uminus -> .)
    SEMICOLON       reduce using rule 61 (uplus_uminus -> .)
    RPARENT         reduce using rule 61 (uplus_uminus -> .)
    WHILE           reduce using rule 61 (uplus_uminus -> .)
    REPEAT          reduce using rule 61 (uplus_uminus -> .)
    BEGIN           reduce using rule 61 (uplus_uminus -> .)
    IF              reduce using rule 61 (uplus_uminus -> .)
    END             reduce using rule 61 (uplus_uminus -> .)
    UNTIL           reduce using rule 61 (uplus_uminus -> .)

  ! UPLUS           [ reduce using rule 61 (uplus_uminus -> .) ]
  ! UMINUS          [ reduce using rule 61 (uplus_uminus -> .) ]

    simple_expr                    shift and go to state 107
    uplus_uminus                   shift and go to state 66

state 84

    (51) relop -> EQUALS .

    UPLUS           reduce using rule 51 (relop -> EQUALS .)
    UMINUS          reduce using rule 51 (relop -> EQUALS .)
    EQUALS          reduce using rule 51 (relop -> EQUALS .)
    LTHAN           reduce using rule 51 (relop -> EQUALS .)
    GTHAN           reduce using rule 51 (relop -> EQUALS .)
    DIFFERENT       reduce using rule 51 (relop -> EQUALS .)
    GEQUALS         reduce using rule 51 (relop -> EQUALS .)
    LEQUALS         reduce using rule 51 (relop -> EQUALS .)
    ID              reduce using rule 51 (relop -> EQUALS .)
    INTEGER         reduce using rule 51 (relop -> EQUALS .)
    REAL            reduce using rule 51 (relop -> EQUALS .)
    STRING          reduce using rule 51 (relop -> EQUALS .)
    NOT             reduce using rule 51 (relop -> EQUALS .)
    PLUS            reduce using rule 51 (relop -> EQUALS .)
    MINUS           reduce using rule 51 (relop -> EQUALS .)
    OR              reduce using rule 51 (relop -> EQUALS .)
    TIMES           reduce using rule 51 (relop -> EQUALS .)
    DIVIDE          reduce using rule 51 (relop -> EQUALS .)
    DIV             reduce using rule 51 (relop -> EQUALS .)
    MOD             reduce using rule 51 (relop -> EQUALS .)
    AND             reduce using rule 51 (relop -> EQUALS .)
    DO              reduce using rule 51 (relop -> EQUALS .)
    COMMA           reduce using rule 51 (relop -> EQUALS .)
    THEN            reduce using rule 51 (relop -> EQUALS .)
    SEMICOLON       reduce using rule 51 (relop -> EQUALS .)
    RPARENT         reduce using rule 51 (relop -> EQUALS .)
    WHILE           reduce using rule 51 (relop -> EQUALS .)
    REPEAT          reduce using rule 51 (relop -> EQUALS .)
    BEGIN           reduce using rule 51 (relop -> EQUALS .)
    IF              reduce using rule 51 (relop -> EQUALS .)
    END             reduce using rule 51 (relop -> EQUALS .)
    UNTIL           reduce using rule 51 (relop -> EQUALS .)


state 85

    (52) relop -> LTHAN .

    UPLUS           reduce using rule 52 (relop -> LTHAN .)
    UMINUS          reduce using rule 52 (relop -> LTHAN .)
    EQUALS          reduce using rule 52 (relop -> LTHAN .)
    LTHAN           reduce using rule 52 (relop -> LTHAN .)
    GTHAN           reduce using rule 52 (relop -> LTHAN .)
    DIFFERENT       reduce using rule 52 (relop -> LTHAN .)
    GEQUALS         reduce using rule 52 (relop -> LTHAN .)
    LEQUALS         reduce using rule 52 (relop -> LTHAN .)
    ID              reduce using rule 52 (relop -> LTHAN .)
    INTEGER         reduce using rule 52 (relop -> LTHAN .)
    REAL            reduce using rule 52 (relop -> LTHAN .)
    STRING          reduce using rule 52 (relop -> LTHAN .)
    NOT             reduce using rule 52 (relop -> LTHAN .)
    PLUS            reduce using rule 52 (relop -> LTHAN .)
    MINUS           reduce using rule 52 (relop -> LTHAN .)
    OR              reduce using rule 52 (relop -> LTHAN .)
    TIMES           reduce using rule 52 (relop -> LTHAN .)
    DIVIDE          reduce using rule 52 (relop -> LTHAN .)
    DIV             reduce using rule 52 (relop -> LTHAN .)
    MOD             reduce using rule 52 (relop -> LTHAN .)
    AND             reduce using rule 52 (relop -> LTHAN .)
    DO              reduce using rule 52 (relop -> LTHAN .)
    COMMA           reduce using rule 52 (relop -> LTHAN .)
    THEN            reduce using rule 52 (relop -> LTHAN .)
    SEMICOLON       reduce using rule 52 (relop -> LTHAN .)
    RPARENT         reduce using rule 52 (relop -> LTHAN .)
    WHILE           reduce using rule 52 (relop -> LTHAN .)
    REPEAT          reduce using rule 52 (relop -> LTHAN .)
    BEGIN           reduce using rule 52 (relop -> LTHAN .)
    IF              reduce using rule 52 (relop -> LTHAN .)
    END             reduce using rule 52 (relop -> LTHAN .)
    UNTIL           reduce using rule 52 (relop -> LTHAN .)


state 86

    (53) relop -> GTHAN .

    UPLUS           reduce using rule 53 (relop -> GTHAN .)
    UMINUS          reduce using rule 53 (relop -> GTHAN .)
    EQUALS          reduce using rule 53 (relop -> GTHAN .)
    LTHAN           reduce using rule 53 (relop -> GTHAN .)
    GTHAN           reduce using rule 53 (relop -> GTHAN .)
    DIFFERENT       reduce using rule 53 (relop -> GTHAN .)
    GEQUALS         reduce using rule 53 (relop -> GTHAN .)
    LEQUALS         reduce using rule 53 (relop -> GTHAN .)
    ID              reduce using rule 53 (relop -> GTHAN .)
    INTEGER         reduce using rule 53 (relop -> GTHAN .)
    REAL            reduce using rule 53 (relop -> GTHAN .)
    STRING          reduce using rule 53 (relop -> GTHAN .)
    NOT             reduce using rule 53 (relop -> GTHAN .)
    PLUS            reduce using rule 53 (relop -> GTHAN .)
    MINUS           reduce using rule 53 (relop -> GTHAN .)
    OR              reduce using rule 53 (relop -> GTHAN .)
    TIMES           reduce using rule 53 (relop -> GTHAN .)
    DIVIDE          reduce using rule 53 (relop -> GTHAN .)
    DIV             reduce using rule 53 (relop -> GTHAN .)
    MOD             reduce using rule 53 (relop -> GTHAN .)
    AND             reduce using rule 53 (relop -> GTHAN .)
    DO              reduce using rule 53 (relop -> GTHAN .)
    COMMA           reduce using rule 53 (relop -> GTHAN .)
    THEN            reduce using rule 53 (relop -> GTHAN .)
    SEMICOLON       reduce using rule 53 (relop -> GTHAN .)
    RPARENT         reduce using rule 53 (relop -> GTHAN .)
    WHILE           reduce using rule 53 (relop -> GTHAN .)
    REPEAT          reduce using rule 53 (relop -> GTHAN .)
    BEGIN           reduce using rule 53 (relop -> GTHAN .)
    IF              reduce using rule 53 (relop -> GTHAN .)
    END             reduce using rule 53 (relop -> GTHAN .)
    UNTIL           reduce using rule 53 (relop -> GTHAN .)


state 87

    (54) relop -> DIFFERENT .

    UPLUS           reduce using rule 54 (relop -> DIFFERENT .)
    UMINUS          reduce using rule 54 (relop -> DIFFERENT .)
    EQUALS          reduce using rule 54 (relop -> DIFFERENT .)
    LTHAN           reduce using rule 54 (relop -> DIFFERENT .)
    GTHAN           reduce using rule 54 (relop -> DIFFERENT .)
    DIFFERENT       reduce using rule 54 (relop -> DIFFERENT .)
    GEQUALS         reduce using rule 54 (relop -> DIFFERENT .)
    LEQUALS         reduce using rule 54 (relop -> DIFFERENT .)
    ID              reduce using rule 54 (relop -> DIFFERENT .)
    INTEGER         reduce using rule 54 (relop -> DIFFERENT .)
    REAL            reduce using rule 54 (relop -> DIFFERENT .)
    STRING          reduce using rule 54 (relop -> DIFFERENT .)
    NOT             reduce using rule 54 (relop -> DIFFERENT .)
    PLUS            reduce using rule 54 (relop -> DIFFERENT .)
    MINUS           reduce using rule 54 (relop -> DIFFERENT .)
    OR              reduce using rule 54 (relop -> DIFFERENT .)
    TIMES           reduce using rule 54 (relop -> DIFFERENT .)
    DIVIDE          reduce using rule 54 (relop -> DIFFERENT .)
    DIV             reduce using rule 54 (relop -> DIFFERENT .)
    MOD             reduce using rule 54 (relop -> DIFFERENT .)
    AND             reduce using rule 54 (relop -> DIFFERENT .)
    DO              reduce using rule 54 (relop -> DIFFERENT .)
    COMMA           reduce using rule 54 (relop -> DIFFERENT .)
    THEN            reduce using rule 54 (relop -> DIFFERENT .)
    SEMICOLON       reduce using rule 54 (relop -> DIFFERENT .)
    RPARENT         reduce using rule 54 (relop -> DIFFERENT .)
    WHILE           reduce using rule 54 (relop -> DIFFERENT .)
    REPEAT          reduce using rule 54 (relop -> DIFFERENT .)
    BEGIN           reduce using rule 54 (relop -> DIFFERENT .)
    IF              reduce using rule 54 (relop -> DIFFERENT .)
    END             reduce using rule 54 (relop -> DIFFERENT .)
    UNTIL           reduce using rule 54 (relop -> DIFFERENT .)


state 88

    (55) relop -> GEQUALS .

    UPLUS           reduce using rule 55 (relop -> GEQUALS .)
    UMINUS          reduce using rule 55 (relop -> GEQUALS .)
    EQUALS          reduce using rule 55 (relop -> GEQUALS .)
    LTHAN           reduce using rule 55 (relop -> GEQUALS .)
    GTHAN           reduce using rule 55 (relop -> GEQUALS .)
    DIFFERENT       reduce using rule 55 (relop -> GEQUALS .)
    GEQUALS         reduce using rule 55 (relop -> GEQUALS .)
    LEQUALS         reduce using rule 55 (relop -> GEQUALS .)
    ID              reduce using rule 55 (relop -> GEQUALS .)
    INTEGER         reduce using rule 55 (relop -> GEQUALS .)
    REAL            reduce using rule 55 (relop -> GEQUALS .)
    STRING          reduce using rule 55 (relop -> GEQUALS .)
    NOT             reduce using rule 55 (relop -> GEQUALS .)
    PLUS            reduce using rule 55 (relop -> GEQUALS .)
    MINUS           reduce using rule 55 (relop -> GEQUALS .)
    OR              reduce using rule 55 (relop -> GEQUALS .)
    TIMES           reduce using rule 55 (relop -> GEQUALS .)
    DIVIDE          reduce using rule 55 (relop -> GEQUALS .)
    DIV             reduce using rule 55 (relop -> GEQUALS .)
    MOD             reduce using rule 55 (relop -> GEQUALS .)
    AND             reduce using rule 55 (relop -> GEQUALS .)
    DO              reduce using rule 55 (relop -> GEQUALS .)
    COMMA           reduce using rule 55 (relop -> GEQUALS .)
    THEN            reduce using rule 55 (relop -> GEQUALS .)
    SEMICOLON       reduce using rule 55 (relop -> GEQUALS .)
    RPARENT         reduce using rule 55 (relop -> GEQUALS .)
    WHILE           reduce using rule 55 (relop -> GEQUALS .)
    REPEAT          reduce using rule 55 (relop -> GEQUALS .)
    BEGIN           reduce using rule 55 (relop -> GEQUALS .)
    IF              reduce using rule 55 (relop -> GEQUALS .)
    END             reduce using rule 55 (relop -> GEQUALS .)
    UNTIL           reduce using rule 55 (relop -> GEQUALS .)


state 89

    (56) relop -> LEQUALS .

    UPLUS           reduce using rule 56 (relop -> LEQUALS .)
    UMINUS          reduce using rule 56 (relop -> LEQUALS .)
    EQUALS          reduce using rule 56 (relop -> LEQUALS .)
    LTHAN           reduce using rule 56 (relop -> LEQUALS .)
    GTHAN           reduce using rule 56 (relop -> LEQUALS .)
    DIFFERENT       reduce using rule 56 (relop -> LEQUALS .)
    GEQUALS         reduce using rule 56 (relop -> LEQUALS .)
    LEQUALS         reduce using rule 56 (relop -> LEQUALS .)
    ID              reduce using rule 56 (relop -> LEQUALS .)
    INTEGER         reduce using rule 56 (relop -> LEQUALS .)
    REAL            reduce using rule 56 (relop -> LEQUALS .)
    STRING          reduce using rule 56 (relop -> LEQUALS .)
    NOT             reduce using rule 56 (relop -> LEQUALS .)
    PLUS            reduce using rule 56 (relop -> LEQUALS .)
    MINUS           reduce using rule 56 (relop -> LEQUALS .)
    OR              reduce using rule 56 (relop -> LEQUALS .)
    TIMES           reduce using rule 56 (relop -> LEQUALS .)
    DIVIDE          reduce using rule 56 (relop -> LEQUALS .)
    DIV             reduce using rule 56 (relop -> LEQUALS .)
    MOD             reduce using rule 56 (relop -> LEQUALS .)
    AND             reduce using rule 56 (relop -> LEQUALS .)
    DO              reduce using rule 56 (relop -> LEQUALS .)
    COMMA           reduce using rule 56 (relop -> LEQUALS .)
    THEN            reduce using rule 56 (relop -> LEQUALS .)
    SEMICOLON       reduce using rule 56 (relop -> LEQUALS .)
    RPARENT         reduce using rule 56 (relop -> LEQUALS .)
    WHILE           reduce using rule 56 (relop -> LEQUALS .)
    REPEAT          reduce using rule 56 (relop -> LEQUALS .)
    BEGIN           reduce using rule 56 (relop -> LEQUALS .)
    IF              reduce using rule 56 (relop -> LEQUALS .)
    END             reduce using rule 56 (relop -> LEQUALS .)
    UNTIL           reduce using rule 56 (relop -> LEQUALS .)


state 90

    (57) simple_expr -> uplus_uminus factor .
    (58) simple_expr -> uplus_uminus factor . addop_mulop factor simple_expr
    (62) addop_mulop -> . PLUS
    (63) addop_mulop -> . MINUS
    (64) addop_mulop -> . OR
    (65) addop_mulop -> . TIMES
    (66) addop_mulop -> . DIVIDE
    (67) addop_mulop -> . DIV
    (68) addop_mulop -> . MOD
    (69) addop_mulop -> . AND
    (70) addop_mulop -> .

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for DIV resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! reduce/reduce conflict for ID resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for EQUALS resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for LTHAN resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for GTHAN resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for GEQUALS resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for LEQUALS resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for DO resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for COMMA resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for THEN resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for SEMICOLON resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for RPARENT resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for WHILE resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for REPEAT resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for BEGIN resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for IF resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for END resolved using rule 57 (simple_expr -> uplus_uminus factor .)
  ! reduce/reduce conflict for UNTIL resolved using rule 57 (simple_expr -> uplus_uminus factor .)
    EQUALS          reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    LTHAN           reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    GTHAN           reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    DIFFERENT       reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    GEQUALS         reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    LEQUALS         reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    DO              reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    COMMA           reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    THEN            reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    SEMICOLON       reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    RPARENT         reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    ID              reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    WHILE           reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    REPEAT          reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    BEGIN           reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    IF              reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    END             reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    UNTIL           reduce using rule 57 (simple_expr -> uplus_uminus factor .)
    PLUS            shift and go to state 109
    MINUS           shift and go to state 110
    OR              shift and go to state 111
    TIMES           shift and go to state 112
    DIVIDE          shift and go to state 113
    DIV             shift and go to state 114
    MOD             shift and go to state 115
    AND             shift and go to state 116
    INTEGER         reduce using rule 70 (addop_mulop -> .)
    REAL            reduce using rule 70 (addop_mulop -> .)
    STRING          reduce using rule 70 (addop_mulop -> .)
    NOT             reduce using rule 70 (addop_mulop -> .)
    UPLUS           reduce using rule 70 (addop_mulop -> .)
    UMINUS          reduce using rule 70 (addop_mulop -> .)

  ! PLUS            [ reduce using rule 70 (addop_mulop -> .) ]
  ! MINUS           [ reduce using rule 70 (addop_mulop -> .) ]
  ! OR              [ reduce using rule 70 (addop_mulop -> .) ]
  ! TIMES           [ reduce using rule 70 (addop_mulop -> .) ]
  ! DIVIDE          [ reduce using rule 70 (addop_mulop -> .) ]
  ! DIV             [ reduce using rule 70 (addop_mulop -> .) ]
  ! MOD             [ reduce using rule 70 (addop_mulop -> .) ]
  ! AND             [ reduce using rule 70 (addop_mulop -> .) ]
  ! ID              [ reduce using rule 70 (addop_mulop -> .) ]
  ! EQUALS          [ reduce using rule 70 (addop_mulop -> .) ]
  ! LTHAN           [ reduce using rule 70 (addop_mulop -> .) ]
  ! GTHAN           [ reduce using rule 70 (addop_mulop -> .) ]
  ! DIFFERENT       [ reduce using rule 70 (addop_mulop -> .) ]
  ! GEQUALS         [ reduce using rule 70 (addop_mulop -> .) ]
  ! LEQUALS         [ reduce using rule 70 (addop_mulop -> .) ]
  ! DO              [ reduce using rule 70 (addop_mulop -> .) ]
  ! COMMA           [ reduce using rule 70 (addop_mulop -> .) ]
  ! THEN            [ reduce using rule 70 (addop_mulop -> .) ]
  ! SEMICOLON       [ reduce using rule 70 (addop_mulop -> .) ]
  ! RPARENT         [ reduce using rule 70 (addop_mulop -> .) ]
  ! WHILE           [ reduce using rule 70 (addop_mulop -> .) ]
  ! REPEAT          [ reduce using rule 70 (addop_mulop -> .) ]
  ! BEGIN           [ reduce using rule 70 (addop_mulop -> .) ]
  ! IF              [ reduce using rule 70 (addop_mulop -> .) ]
  ! END             [ reduce using rule 70 (addop_mulop -> .) ]
  ! UNTIL           [ reduce using rule 70 (addop_mulop -> .) ]

    addop_mulop                    shift and go to state 108

state 91

    (71) factor -> ID .

    PLUS            reduce using rule 71 (factor -> ID .)
    MINUS           reduce using rule 71 (factor -> ID .)
    OR              reduce using rule 71 (factor -> ID .)
    TIMES           reduce using rule 71 (factor -> ID .)
    DIVIDE          reduce using rule 71 (factor -> ID .)
    DIV             reduce using rule 71 (factor -> ID .)
    MOD             reduce using rule 71 (factor -> ID .)
    AND             reduce using rule 71 (factor -> ID .)
    ID              reduce using rule 71 (factor -> ID .)
    INTEGER         reduce using rule 71 (factor -> ID .)
    REAL            reduce using rule 71 (factor -> ID .)
    STRING          reduce using rule 71 (factor -> ID .)
    NOT             reduce using rule 71 (factor -> ID .)
    UPLUS           reduce using rule 71 (factor -> ID .)
    UMINUS          reduce using rule 71 (factor -> ID .)
    EQUALS          reduce using rule 71 (factor -> ID .)
    LTHAN           reduce using rule 71 (factor -> ID .)
    GTHAN           reduce using rule 71 (factor -> ID .)
    DIFFERENT       reduce using rule 71 (factor -> ID .)
    GEQUALS         reduce using rule 71 (factor -> ID .)
    LEQUALS         reduce using rule 71 (factor -> ID .)
    DO              reduce using rule 71 (factor -> ID .)
    COMMA           reduce using rule 71 (factor -> ID .)
    THEN            reduce using rule 71 (factor -> ID .)
    SEMICOLON       reduce using rule 71 (factor -> ID .)
    RPARENT         reduce using rule 71 (factor -> ID .)
    WHILE           reduce using rule 71 (factor -> ID .)
    REPEAT          reduce using rule 71 (factor -> ID .)
    BEGIN           reduce using rule 71 (factor -> ID .)
    IF              reduce using rule 71 (factor -> ID .)
    END             reduce using rule 71 (factor -> ID .)
    UNTIL           reduce using rule 71 (factor -> ID .)


state 92

    (72) factor -> INTEGER .

    PLUS            reduce using rule 72 (factor -> INTEGER .)
    MINUS           reduce using rule 72 (factor -> INTEGER .)
    OR              reduce using rule 72 (factor -> INTEGER .)
    TIMES           reduce using rule 72 (factor -> INTEGER .)
    DIVIDE          reduce using rule 72 (factor -> INTEGER .)
    DIV             reduce using rule 72 (factor -> INTEGER .)
    MOD             reduce using rule 72 (factor -> INTEGER .)
    AND             reduce using rule 72 (factor -> INTEGER .)
    ID              reduce using rule 72 (factor -> INTEGER .)
    INTEGER         reduce using rule 72 (factor -> INTEGER .)
    REAL            reduce using rule 72 (factor -> INTEGER .)
    STRING          reduce using rule 72 (factor -> INTEGER .)
    NOT             reduce using rule 72 (factor -> INTEGER .)
    UPLUS           reduce using rule 72 (factor -> INTEGER .)
    UMINUS          reduce using rule 72 (factor -> INTEGER .)
    EQUALS          reduce using rule 72 (factor -> INTEGER .)
    LTHAN           reduce using rule 72 (factor -> INTEGER .)
    GTHAN           reduce using rule 72 (factor -> INTEGER .)
    DIFFERENT       reduce using rule 72 (factor -> INTEGER .)
    GEQUALS         reduce using rule 72 (factor -> INTEGER .)
    LEQUALS         reduce using rule 72 (factor -> INTEGER .)
    DO              reduce using rule 72 (factor -> INTEGER .)
    COMMA           reduce using rule 72 (factor -> INTEGER .)
    THEN            reduce using rule 72 (factor -> INTEGER .)
    SEMICOLON       reduce using rule 72 (factor -> INTEGER .)
    RPARENT         reduce using rule 72 (factor -> INTEGER .)
    WHILE           reduce using rule 72 (factor -> INTEGER .)
    REPEAT          reduce using rule 72 (factor -> INTEGER .)
    BEGIN           reduce using rule 72 (factor -> INTEGER .)
    IF              reduce using rule 72 (factor -> INTEGER .)
    END             reduce using rule 72 (factor -> INTEGER .)
    UNTIL           reduce using rule 72 (factor -> INTEGER .)


state 93

    (73) factor -> REAL .

    PLUS            reduce using rule 73 (factor -> REAL .)
    MINUS           reduce using rule 73 (factor -> REAL .)
    OR              reduce using rule 73 (factor -> REAL .)
    TIMES           reduce using rule 73 (factor -> REAL .)
    DIVIDE          reduce using rule 73 (factor -> REAL .)
    DIV             reduce using rule 73 (factor -> REAL .)
    MOD             reduce using rule 73 (factor -> REAL .)
    AND             reduce using rule 73 (factor -> REAL .)
    ID              reduce using rule 73 (factor -> REAL .)
    INTEGER         reduce using rule 73 (factor -> REAL .)
    REAL            reduce using rule 73 (factor -> REAL .)
    STRING          reduce using rule 73 (factor -> REAL .)
    NOT             reduce using rule 73 (factor -> REAL .)
    UPLUS           reduce using rule 73 (factor -> REAL .)
    UMINUS          reduce using rule 73 (factor -> REAL .)
    EQUALS          reduce using rule 73 (factor -> REAL .)
    LTHAN           reduce using rule 73 (factor -> REAL .)
    GTHAN           reduce using rule 73 (factor -> REAL .)
    DIFFERENT       reduce using rule 73 (factor -> REAL .)
    GEQUALS         reduce using rule 73 (factor -> REAL .)
    LEQUALS         reduce using rule 73 (factor -> REAL .)
    DO              reduce using rule 73 (factor -> REAL .)
    COMMA           reduce using rule 73 (factor -> REAL .)
    THEN            reduce using rule 73 (factor -> REAL .)
    SEMICOLON       reduce using rule 73 (factor -> REAL .)
    RPARENT         reduce using rule 73 (factor -> REAL .)
    WHILE           reduce using rule 73 (factor -> REAL .)
    REPEAT          reduce using rule 73 (factor -> REAL .)
    BEGIN           reduce using rule 73 (factor -> REAL .)
    IF              reduce using rule 73 (factor -> REAL .)
    END             reduce using rule 73 (factor -> REAL .)
    UNTIL           reduce using rule 73 (factor -> REAL .)


state 94

    (74) factor -> STRING .

    PLUS            reduce using rule 74 (factor -> STRING .)
    MINUS           reduce using rule 74 (factor -> STRING .)
    OR              reduce using rule 74 (factor -> STRING .)
    TIMES           reduce using rule 74 (factor -> STRING .)
    DIVIDE          reduce using rule 74 (factor -> STRING .)
    DIV             reduce using rule 74 (factor -> STRING .)
    MOD             reduce using rule 74 (factor -> STRING .)
    AND             reduce using rule 74 (factor -> STRING .)
    ID              reduce using rule 74 (factor -> STRING .)
    INTEGER         reduce using rule 74 (factor -> STRING .)
    REAL            reduce using rule 74 (factor -> STRING .)
    STRING          reduce using rule 74 (factor -> STRING .)
    NOT             reduce using rule 74 (factor -> STRING .)
    UPLUS           reduce using rule 74 (factor -> STRING .)
    UMINUS          reduce using rule 74 (factor -> STRING .)
    EQUALS          reduce using rule 74 (factor -> STRING .)
    LTHAN           reduce using rule 74 (factor -> STRING .)
    GTHAN           reduce using rule 74 (factor -> STRING .)
    DIFFERENT       reduce using rule 74 (factor -> STRING .)
    GEQUALS         reduce using rule 74 (factor -> STRING .)
    LEQUALS         reduce using rule 74 (factor -> STRING .)
    DO              reduce using rule 74 (factor -> STRING .)
    COMMA           reduce using rule 74 (factor -> STRING .)
    THEN            reduce using rule 74 (factor -> STRING .)
    SEMICOLON       reduce using rule 74 (factor -> STRING .)
    RPARENT         reduce using rule 74 (factor -> STRING .)
    WHILE           reduce using rule 74 (factor -> STRING .)
    REPEAT          reduce using rule 74 (factor -> STRING .)
    BEGIN           reduce using rule 74 (factor -> STRING .)
    IF              reduce using rule 74 (factor -> STRING .)
    END             reduce using rule 74 (factor -> STRING .)
    UNTIL           reduce using rule 74 (factor -> STRING .)


state 95

    (75) factor -> NOT . factor
    (71) factor -> . ID
    (72) factor -> . INTEGER
    (73) factor -> . REAL
    (74) factor -> . STRING
    (75) factor -> . NOT factor
    (76) factor -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    ID              shift and go to state 91
    INTEGER         shift and go to state 92
    REAL            shift and go to state 93
    STRING          shift and go to state 94
    NOT             shift and go to state 95
    PLUS            reduce using rule 76 (factor -> .)
    MINUS           reduce using rule 76 (factor -> .)
    OR              reduce using rule 76 (factor -> .)
    TIMES           reduce using rule 76 (factor -> .)
    DIVIDE          reduce using rule 76 (factor -> .)
    DIV             reduce using rule 76 (factor -> .)
    MOD             reduce using rule 76 (factor -> .)
    AND             reduce using rule 76 (factor -> .)
    UPLUS           reduce using rule 76 (factor -> .)
    UMINUS          reduce using rule 76 (factor -> .)
    EQUALS          reduce using rule 76 (factor -> .)
    LTHAN           reduce using rule 76 (factor -> .)
    GTHAN           reduce using rule 76 (factor -> .)
    DIFFERENT       reduce using rule 76 (factor -> .)
    GEQUALS         reduce using rule 76 (factor -> .)
    LEQUALS         reduce using rule 76 (factor -> .)
    DO              reduce using rule 76 (factor -> .)
    COMMA           reduce using rule 76 (factor -> .)
    THEN            reduce using rule 76 (factor -> .)
    SEMICOLON       reduce using rule 76 (factor -> .)
    RPARENT         reduce using rule 76 (factor -> .)
    WHILE           reduce using rule 76 (factor -> .)
    REPEAT          reduce using rule 76 (factor -> .)
    BEGIN           reduce using rule 76 (factor -> .)
    IF              reduce using rule 76 (factor -> .)
    END             reduce using rule 76 (factor -> .)
    UNTIL           reduce using rule 76 (factor -> .)

  ! ID              [ reduce using rule 76 (factor -> .) ]
  ! INTEGER         [ reduce using rule 76 (factor -> .) ]
  ! REAL            [ reduce using rule 76 (factor -> .) ]
  ! STRING          [ reduce using rule 76 (factor -> .) ]
  ! NOT             [ reduce using rule 76 (factor -> .) ]

    factor                         shift and go to state 117

state 96

    (45) repeat_statement -> REPEAT statement UNTIL . expr
    (48) expr -> . simple_expr relop_simple_expr
    (57) simple_expr -> . uplus_uminus factor
    (58) simple_expr -> . uplus_uminus factor addop_mulop factor simple_expr
    (59) uplus_uminus -> . UPLUS
    (60) uplus_uminus -> . UMINUS
    (61) uplus_uminus -> .

  ! shift/reduce conflict for UPLUS resolved as shift
  ! shift/reduce conflict for UMINUS resolved as shift
    UPLUS           shift and go to state 67
    UMINUS          shift and go to state 68
    ID              reduce using rule 61 (uplus_uminus -> .)
    INTEGER         reduce using rule 61 (uplus_uminus -> .)
    REAL            reduce using rule 61 (uplus_uminus -> .)
    STRING          reduce using rule 61 (uplus_uminus -> .)
    NOT             reduce using rule 61 (uplus_uminus -> .)
    PLUS            reduce using rule 61 (uplus_uminus -> .)
    MINUS           reduce using rule 61 (uplus_uminus -> .)
    OR              reduce using rule 61 (uplus_uminus -> .)
    TIMES           reduce using rule 61 (uplus_uminus -> .)
    DIVIDE          reduce using rule 61 (uplus_uminus -> .)
    DIV             reduce using rule 61 (uplus_uminus -> .)
    MOD             reduce using rule 61 (uplus_uminus -> .)
    AND             reduce using rule 61 (uplus_uminus -> .)
    EQUALS          reduce using rule 61 (uplus_uminus -> .)
    LTHAN           reduce using rule 61 (uplus_uminus -> .)
    GTHAN           reduce using rule 61 (uplus_uminus -> .)
    DIFFERENT       reduce using rule 61 (uplus_uminus -> .)
    GEQUALS         reduce using rule 61 (uplus_uminus -> .)
    LEQUALS         reduce using rule 61 (uplus_uminus -> .)
    WHILE           reduce using rule 61 (uplus_uminus -> .)
    REPEAT          reduce using rule 61 (uplus_uminus -> .)
    BEGIN           reduce using rule 61 (uplus_uminus -> .)
    IF              reduce using rule 61 (uplus_uminus -> .)
    SEMICOLON       reduce using rule 61 (uplus_uminus -> .)
    END             reduce using rule 61 (uplus_uminus -> .)
    UNTIL           reduce using rule 61 (uplus_uminus -> .)

  ! UPLUS           [ reduce using rule 61 (uplus_uminus -> .) ]
  ! UMINUS          [ reduce using rule 61 (uplus_uminus -> .) ]

    expr                           shift and go to state 118
    simple_expr                    shift and go to state 65
    uplus_uminus                   shift and go to state 66

state 97

    (40) if1 -> IF expr_list THEN . if1 ELSE if1
    (42) if2 -> IF expr_list THEN . if_statement
    (43) if2 -> IF expr_list THEN . if1 ELSE if2
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (38) if_statement -> . if1
    (39) if_statement -> . if2
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for IF resolved as shift
    IF              shift and go to state 48
    ELSE            reduce using rule 41 (if1 -> .)
    ID              reduce using rule 41 (if1 -> .)
    WHILE           reduce using rule 41 (if1 -> .)
    REPEAT          reduce using rule 41 (if1 -> .)
    BEGIN           reduce using rule 41 (if1 -> .)
    SEMICOLON       reduce using rule 41 (if1 -> .)
    END             reduce using rule 41 (if1 -> .)
    UNTIL           reduce using rule 41 (if1 -> .)

  ! IF              [ reduce using rule 41 (if1 -> .) ]

    if1                            shift and go to state 119
    if_statement                   shift and go to state 120
    if2                            shift and go to state 45

state 98

    (47) expr_list -> expr COMMA . expr_list
    (46) expr_list -> . expr
    (47) expr_list -> . expr COMMA expr_list
    (48) expr -> . simple_expr relop_simple_expr
    (57) simple_expr -> . uplus_uminus factor
    (58) simple_expr -> . uplus_uminus factor addop_mulop factor simple_expr
    (59) uplus_uminus -> . UPLUS
    (60) uplus_uminus -> . UMINUS
    (61) uplus_uminus -> .

  ! shift/reduce conflict for UPLUS resolved as shift
  ! shift/reduce conflict for UMINUS resolved as shift
    UPLUS           shift and go to state 67
    UMINUS          shift and go to state 68
    ID              reduce using rule 61 (uplus_uminus -> .)
    INTEGER         reduce using rule 61 (uplus_uminus -> .)
    REAL            reduce using rule 61 (uplus_uminus -> .)
    STRING          reduce using rule 61 (uplus_uminus -> .)
    NOT             reduce using rule 61 (uplus_uminus -> .)
    PLUS            reduce using rule 61 (uplus_uminus -> .)
    MINUS           reduce using rule 61 (uplus_uminus -> .)
    OR              reduce using rule 61 (uplus_uminus -> .)
    TIMES           reduce using rule 61 (uplus_uminus -> .)
    DIVIDE          reduce using rule 61 (uplus_uminus -> .)
    DIV             reduce using rule 61 (uplus_uminus -> .)
    MOD             reduce using rule 61 (uplus_uminus -> .)
    AND             reduce using rule 61 (uplus_uminus -> .)
    EQUALS          reduce using rule 61 (uplus_uminus -> .)
    LTHAN           reduce using rule 61 (uplus_uminus -> .)
    GTHAN           reduce using rule 61 (uplus_uminus -> .)
    DIFFERENT       reduce using rule 61 (uplus_uminus -> .)
    GEQUALS         reduce using rule 61 (uplus_uminus -> .)
    LEQUALS         reduce using rule 61 (uplus_uminus -> .)
    COMMA           reduce using rule 61 (uplus_uminus -> .)
    THEN            reduce using rule 61 (uplus_uminus -> .)
    RPARENT         reduce using rule 61 (uplus_uminus -> .)

  ! UPLUS           [ reduce using rule 61 (uplus_uminus -> .) ]
  ! UMINUS          [ reduce using rule 61 (uplus_uminus -> .) ]

    expr                           shift and go to state 71
    expr_list                      shift and go to state 121
    simple_expr                    shift and go to state 65
    uplus_uminus                   shift and go to state 66

state 99

    (23) procedure_declaration -> PROCEDURE ID LPARENT param_section RPARENT . SEMICOLON

    SEMICOLON       shift and go to state 122


state 100

    (25) param_section -> identifier_list TWOPOINTS . types SEMICOLON param_section
    (12) types -> . INTEGER
    (13) types -> . REAL
    (14) types -> . STRING
    (15) types -> . BOOLEAN
    (16) types -> . CHAR
    (17) types -> . ID

    INTEGER         shift and go to state 31
    REAL            shift and go to state 32
    STRING          shift and go to state 33
    BOOLEAN         shift and go to state 34
    CHAR            shift and go to state 35
    ID              shift and go to state 29

    types                          shift and go to state 123

state 101

    (24) function_declaration -> FUNCTION ID LPARENT param_section RPARENT . TWOPOINTS types SEMICOLON

    TWOPOINTS       shift and go to state 124


state 102

    (10) var_declaration -> identifier_list TWOPOINTS types SEMICOLON var_declaration .

    PROCEDURE       reduce using rule 10 (var_declaration -> identifier_list TWOPOINTS types SEMICOLON var_declaration .)
    FUNCTION        reduce using rule 10 (var_declaration -> identifier_list TWOPOINTS types SEMICOLON var_declaration .)
    BEGIN           reduce using rule 10 (var_declaration -> identifier_list TWOPOINTS types SEMICOLON var_declaration .)


state 103

    (27) compound_statement -> BEGIN statement SEMICOLON statement END . SEMICOLON

    SEMICOLON       shift and go to state 125


state 104

    (36) assign_statement -> ID ASSIGNMENT expr SEMICOLON .

    ID              reduce using rule 36 (assign_statement -> ID ASSIGNMENT expr SEMICOLON .)
    WHILE           reduce using rule 36 (assign_statement -> ID ASSIGNMENT expr SEMICOLON .)
    REPEAT          reduce using rule 36 (assign_statement -> ID ASSIGNMENT expr SEMICOLON .)
    BEGIN           reduce using rule 36 (assign_statement -> ID ASSIGNMENT expr SEMICOLON .)
    IF              reduce using rule 36 (assign_statement -> ID ASSIGNMENT expr SEMICOLON .)
    SEMICOLON       reduce using rule 36 (assign_statement -> ID ASSIGNMENT expr SEMICOLON .)
    END             reduce using rule 36 (assign_statement -> ID ASSIGNMENT expr SEMICOLON .)
    UNTIL           reduce using rule 36 (assign_statement -> ID ASSIGNMENT expr SEMICOLON .)


state 105

    (37) procedure_call -> ID LPARENT expr_list RPARENT . SEMICOLON

    SEMICOLON       shift and go to state 126


state 106

    (44) while_statement -> WHILE expr DO statement .

    ID              reduce using rule 44 (while_statement -> WHILE expr DO statement .)
    WHILE           reduce using rule 44 (while_statement -> WHILE expr DO statement .)
    REPEAT          reduce using rule 44 (while_statement -> WHILE expr DO statement .)
    BEGIN           reduce using rule 44 (while_statement -> WHILE expr DO statement .)
    IF              reduce using rule 44 (while_statement -> WHILE expr DO statement .)
    SEMICOLON       reduce using rule 44 (while_statement -> WHILE expr DO statement .)
    END             reduce using rule 44 (while_statement -> WHILE expr DO statement .)
    UNTIL           reduce using rule 44 (while_statement -> WHILE expr DO statement .)


state 107

    (49) relop_simple_expr -> relop simple_expr . relop_simple_expr
    (49) relop_simple_expr -> . relop simple_expr relop_simple_expr
    (50) relop_simple_expr -> .
    (51) relop -> . EQUALS
    (52) relop -> . LTHAN
    (53) relop -> . GTHAN
    (54) relop -> . DIFFERENT
    (55) relop -> . GEQUALS
    (56) relop -> . LEQUALS

    DO              reduce using rule 50 (relop_simple_expr -> .)
    COMMA           reduce using rule 50 (relop_simple_expr -> .)
    THEN            reduce using rule 50 (relop_simple_expr -> .)
    SEMICOLON       reduce using rule 50 (relop_simple_expr -> .)
    RPARENT         reduce using rule 50 (relop_simple_expr -> .)
    ID              reduce using rule 50 (relop_simple_expr -> .)
    WHILE           reduce using rule 50 (relop_simple_expr -> .)
    REPEAT          reduce using rule 50 (relop_simple_expr -> .)
    BEGIN           reduce using rule 50 (relop_simple_expr -> .)
    IF              reduce using rule 50 (relop_simple_expr -> .)
    END             reduce using rule 50 (relop_simple_expr -> .)
    UNTIL           reduce using rule 50 (relop_simple_expr -> .)
    EQUALS          shift and go to state 84
    LTHAN           shift and go to state 85
    GTHAN           shift and go to state 86
    DIFFERENT       shift and go to state 87
    GEQUALS         shift and go to state 88
    LEQUALS         shift and go to state 89

    relop                          shift and go to state 83
    relop_simple_expr              shift and go to state 127

state 108

    (58) simple_expr -> uplus_uminus factor addop_mulop . factor simple_expr
    (71) factor -> . ID
    (72) factor -> . INTEGER
    (73) factor -> . REAL
    (74) factor -> . STRING
    (75) factor -> . NOT factor
    (76) factor -> .

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for REAL resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    ID              shift and go to state 91
    INTEGER         shift and go to state 92
    REAL            shift and go to state 93
    STRING          shift and go to state 94
    NOT             shift and go to state 95
    PLUS            reduce using rule 76 (factor -> .)
    MINUS           reduce using rule 76 (factor -> .)
    OR              reduce using rule 76 (factor -> .)
    TIMES           reduce using rule 76 (factor -> .)
    DIVIDE          reduce using rule 76 (factor -> .)
    DIV             reduce using rule 76 (factor -> .)
    MOD             reduce using rule 76 (factor -> .)
    AND             reduce using rule 76 (factor -> .)
    UPLUS           reduce using rule 76 (factor -> .)
    UMINUS          reduce using rule 76 (factor -> .)
    EQUALS          reduce using rule 76 (factor -> .)
    LTHAN           reduce using rule 76 (factor -> .)
    GTHAN           reduce using rule 76 (factor -> .)
    DIFFERENT       reduce using rule 76 (factor -> .)
    GEQUALS         reduce using rule 76 (factor -> .)
    LEQUALS         reduce using rule 76 (factor -> .)
    DO              reduce using rule 76 (factor -> .)
    COMMA           reduce using rule 76 (factor -> .)
    THEN            reduce using rule 76 (factor -> .)
    SEMICOLON       reduce using rule 76 (factor -> .)
    RPARENT         reduce using rule 76 (factor -> .)
    WHILE           reduce using rule 76 (factor -> .)
    REPEAT          reduce using rule 76 (factor -> .)
    BEGIN           reduce using rule 76 (factor -> .)
    IF              reduce using rule 76 (factor -> .)
    END             reduce using rule 76 (factor -> .)
    UNTIL           reduce using rule 76 (factor -> .)

  ! ID              [ reduce using rule 76 (factor -> .) ]
  ! INTEGER         [ reduce using rule 76 (factor -> .) ]
  ! REAL            [ reduce using rule 76 (factor -> .) ]
  ! STRING          [ reduce using rule 76 (factor -> .) ]
  ! NOT             [ reduce using rule 76 (factor -> .) ]

    factor                         shift and go to state 128

state 109

    (62) addop_mulop -> PLUS .

    PLUS            reduce using rule 62 (addop_mulop -> PLUS .)
    MINUS           reduce using rule 62 (addop_mulop -> PLUS .)
    OR              reduce using rule 62 (addop_mulop -> PLUS .)
    TIMES           reduce using rule 62 (addop_mulop -> PLUS .)
    DIVIDE          reduce using rule 62 (addop_mulop -> PLUS .)
    DIV             reduce using rule 62 (addop_mulop -> PLUS .)
    MOD             reduce using rule 62 (addop_mulop -> PLUS .)
    AND             reduce using rule 62 (addop_mulop -> PLUS .)
    ID              reduce using rule 62 (addop_mulop -> PLUS .)
    INTEGER         reduce using rule 62 (addop_mulop -> PLUS .)
    REAL            reduce using rule 62 (addop_mulop -> PLUS .)
    STRING          reduce using rule 62 (addop_mulop -> PLUS .)
    NOT             reduce using rule 62 (addop_mulop -> PLUS .)
    UPLUS           reduce using rule 62 (addop_mulop -> PLUS .)
    UMINUS          reduce using rule 62 (addop_mulop -> PLUS .)
    EQUALS          reduce using rule 62 (addop_mulop -> PLUS .)
    LTHAN           reduce using rule 62 (addop_mulop -> PLUS .)
    GTHAN           reduce using rule 62 (addop_mulop -> PLUS .)
    DIFFERENT       reduce using rule 62 (addop_mulop -> PLUS .)
    GEQUALS         reduce using rule 62 (addop_mulop -> PLUS .)
    LEQUALS         reduce using rule 62 (addop_mulop -> PLUS .)
    DO              reduce using rule 62 (addop_mulop -> PLUS .)
    COMMA           reduce using rule 62 (addop_mulop -> PLUS .)
    THEN            reduce using rule 62 (addop_mulop -> PLUS .)
    SEMICOLON       reduce using rule 62 (addop_mulop -> PLUS .)
    RPARENT         reduce using rule 62 (addop_mulop -> PLUS .)
    WHILE           reduce using rule 62 (addop_mulop -> PLUS .)
    REPEAT          reduce using rule 62 (addop_mulop -> PLUS .)
    BEGIN           reduce using rule 62 (addop_mulop -> PLUS .)
    IF              reduce using rule 62 (addop_mulop -> PLUS .)
    END             reduce using rule 62 (addop_mulop -> PLUS .)
    UNTIL           reduce using rule 62 (addop_mulop -> PLUS .)


state 110

    (63) addop_mulop -> MINUS .

    PLUS            reduce using rule 63 (addop_mulop -> MINUS .)
    MINUS           reduce using rule 63 (addop_mulop -> MINUS .)
    OR              reduce using rule 63 (addop_mulop -> MINUS .)
    TIMES           reduce using rule 63 (addop_mulop -> MINUS .)
    DIVIDE          reduce using rule 63 (addop_mulop -> MINUS .)
    DIV             reduce using rule 63 (addop_mulop -> MINUS .)
    MOD             reduce using rule 63 (addop_mulop -> MINUS .)
    AND             reduce using rule 63 (addop_mulop -> MINUS .)
    ID              reduce using rule 63 (addop_mulop -> MINUS .)
    INTEGER         reduce using rule 63 (addop_mulop -> MINUS .)
    REAL            reduce using rule 63 (addop_mulop -> MINUS .)
    STRING          reduce using rule 63 (addop_mulop -> MINUS .)
    NOT             reduce using rule 63 (addop_mulop -> MINUS .)
    UPLUS           reduce using rule 63 (addop_mulop -> MINUS .)
    UMINUS          reduce using rule 63 (addop_mulop -> MINUS .)
    EQUALS          reduce using rule 63 (addop_mulop -> MINUS .)
    LTHAN           reduce using rule 63 (addop_mulop -> MINUS .)
    GTHAN           reduce using rule 63 (addop_mulop -> MINUS .)
    DIFFERENT       reduce using rule 63 (addop_mulop -> MINUS .)
    GEQUALS         reduce using rule 63 (addop_mulop -> MINUS .)
    LEQUALS         reduce using rule 63 (addop_mulop -> MINUS .)
    DO              reduce using rule 63 (addop_mulop -> MINUS .)
    COMMA           reduce using rule 63 (addop_mulop -> MINUS .)
    THEN            reduce using rule 63 (addop_mulop -> MINUS .)
    SEMICOLON       reduce using rule 63 (addop_mulop -> MINUS .)
    RPARENT         reduce using rule 63 (addop_mulop -> MINUS .)
    WHILE           reduce using rule 63 (addop_mulop -> MINUS .)
    REPEAT          reduce using rule 63 (addop_mulop -> MINUS .)
    BEGIN           reduce using rule 63 (addop_mulop -> MINUS .)
    IF              reduce using rule 63 (addop_mulop -> MINUS .)
    END             reduce using rule 63 (addop_mulop -> MINUS .)
    UNTIL           reduce using rule 63 (addop_mulop -> MINUS .)


state 111

    (64) addop_mulop -> OR .

    PLUS            reduce using rule 64 (addop_mulop -> OR .)
    MINUS           reduce using rule 64 (addop_mulop -> OR .)
    OR              reduce using rule 64 (addop_mulop -> OR .)
    TIMES           reduce using rule 64 (addop_mulop -> OR .)
    DIVIDE          reduce using rule 64 (addop_mulop -> OR .)
    DIV             reduce using rule 64 (addop_mulop -> OR .)
    MOD             reduce using rule 64 (addop_mulop -> OR .)
    AND             reduce using rule 64 (addop_mulop -> OR .)
    ID              reduce using rule 64 (addop_mulop -> OR .)
    INTEGER         reduce using rule 64 (addop_mulop -> OR .)
    REAL            reduce using rule 64 (addop_mulop -> OR .)
    STRING          reduce using rule 64 (addop_mulop -> OR .)
    NOT             reduce using rule 64 (addop_mulop -> OR .)
    UPLUS           reduce using rule 64 (addop_mulop -> OR .)
    UMINUS          reduce using rule 64 (addop_mulop -> OR .)
    EQUALS          reduce using rule 64 (addop_mulop -> OR .)
    LTHAN           reduce using rule 64 (addop_mulop -> OR .)
    GTHAN           reduce using rule 64 (addop_mulop -> OR .)
    DIFFERENT       reduce using rule 64 (addop_mulop -> OR .)
    GEQUALS         reduce using rule 64 (addop_mulop -> OR .)
    LEQUALS         reduce using rule 64 (addop_mulop -> OR .)
    DO              reduce using rule 64 (addop_mulop -> OR .)
    COMMA           reduce using rule 64 (addop_mulop -> OR .)
    THEN            reduce using rule 64 (addop_mulop -> OR .)
    SEMICOLON       reduce using rule 64 (addop_mulop -> OR .)
    RPARENT         reduce using rule 64 (addop_mulop -> OR .)
    WHILE           reduce using rule 64 (addop_mulop -> OR .)
    REPEAT          reduce using rule 64 (addop_mulop -> OR .)
    BEGIN           reduce using rule 64 (addop_mulop -> OR .)
    IF              reduce using rule 64 (addop_mulop -> OR .)
    END             reduce using rule 64 (addop_mulop -> OR .)
    UNTIL           reduce using rule 64 (addop_mulop -> OR .)


state 112

    (65) addop_mulop -> TIMES .

    PLUS            reduce using rule 65 (addop_mulop -> TIMES .)
    MINUS           reduce using rule 65 (addop_mulop -> TIMES .)
    OR              reduce using rule 65 (addop_mulop -> TIMES .)
    TIMES           reduce using rule 65 (addop_mulop -> TIMES .)
    DIVIDE          reduce using rule 65 (addop_mulop -> TIMES .)
    DIV             reduce using rule 65 (addop_mulop -> TIMES .)
    MOD             reduce using rule 65 (addop_mulop -> TIMES .)
    AND             reduce using rule 65 (addop_mulop -> TIMES .)
    ID              reduce using rule 65 (addop_mulop -> TIMES .)
    INTEGER         reduce using rule 65 (addop_mulop -> TIMES .)
    REAL            reduce using rule 65 (addop_mulop -> TIMES .)
    STRING          reduce using rule 65 (addop_mulop -> TIMES .)
    NOT             reduce using rule 65 (addop_mulop -> TIMES .)
    UPLUS           reduce using rule 65 (addop_mulop -> TIMES .)
    UMINUS          reduce using rule 65 (addop_mulop -> TIMES .)
    EQUALS          reduce using rule 65 (addop_mulop -> TIMES .)
    LTHAN           reduce using rule 65 (addop_mulop -> TIMES .)
    GTHAN           reduce using rule 65 (addop_mulop -> TIMES .)
    DIFFERENT       reduce using rule 65 (addop_mulop -> TIMES .)
    GEQUALS         reduce using rule 65 (addop_mulop -> TIMES .)
    LEQUALS         reduce using rule 65 (addop_mulop -> TIMES .)
    DO              reduce using rule 65 (addop_mulop -> TIMES .)
    COMMA           reduce using rule 65 (addop_mulop -> TIMES .)
    THEN            reduce using rule 65 (addop_mulop -> TIMES .)
    SEMICOLON       reduce using rule 65 (addop_mulop -> TIMES .)
    RPARENT         reduce using rule 65 (addop_mulop -> TIMES .)
    WHILE           reduce using rule 65 (addop_mulop -> TIMES .)
    REPEAT          reduce using rule 65 (addop_mulop -> TIMES .)
    BEGIN           reduce using rule 65 (addop_mulop -> TIMES .)
    IF              reduce using rule 65 (addop_mulop -> TIMES .)
    END             reduce using rule 65 (addop_mulop -> TIMES .)
    UNTIL           reduce using rule 65 (addop_mulop -> TIMES .)


state 113

    (66) addop_mulop -> DIVIDE .

    PLUS            reduce using rule 66 (addop_mulop -> DIVIDE .)
    MINUS           reduce using rule 66 (addop_mulop -> DIVIDE .)
    OR              reduce using rule 66 (addop_mulop -> DIVIDE .)
    TIMES           reduce using rule 66 (addop_mulop -> DIVIDE .)
    DIVIDE          reduce using rule 66 (addop_mulop -> DIVIDE .)
    DIV             reduce using rule 66 (addop_mulop -> DIVIDE .)
    MOD             reduce using rule 66 (addop_mulop -> DIVIDE .)
    AND             reduce using rule 66 (addop_mulop -> DIVIDE .)
    ID              reduce using rule 66 (addop_mulop -> DIVIDE .)
    INTEGER         reduce using rule 66 (addop_mulop -> DIVIDE .)
    REAL            reduce using rule 66 (addop_mulop -> DIVIDE .)
    STRING          reduce using rule 66 (addop_mulop -> DIVIDE .)
    NOT             reduce using rule 66 (addop_mulop -> DIVIDE .)
    UPLUS           reduce using rule 66 (addop_mulop -> DIVIDE .)
    UMINUS          reduce using rule 66 (addop_mulop -> DIVIDE .)
    EQUALS          reduce using rule 66 (addop_mulop -> DIVIDE .)
    LTHAN           reduce using rule 66 (addop_mulop -> DIVIDE .)
    GTHAN           reduce using rule 66 (addop_mulop -> DIVIDE .)
    DIFFERENT       reduce using rule 66 (addop_mulop -> DIVIDE .)
    GEQUALS         reduce using rule 66 (addop_mulop -> DIVIDE .)
    LEQUALS         reduce using rule 66 (addop_mulop -> DIVIDE .)
    DO              reduce using rule 66 (addop_mulop -> DIVIDE .)
    COMMA           reduce using rule 66 (addop_mulop -> DIVIDE .)
    THEN            reduce using rule 66 (addop_mulop -> DIVIDE .)
    SEMICOLON       reduce using rule 66 (addop_mulop -> DIVIDE .)
    RPARENT         reduce using rule 66 (addop_mulop -> DIVIDE .)
    WHILE           reduce using rule 66 (addop_mulop -> DIVIDE .)
    REPEAT          reduce using rule 66 (addop_mulop -> DIVIDE .)
    BEGIN           reduce using rule 66 (addop_mulop -> DIVIDE .)
    IF              reduce using rule 66 (addop_mulop -> DIVIDE .)
    END             reduce using rule 66 (addop_mulop -> DIVIDE .)
    UNTIL           reduce using rule 66 (addop_mulop -> DIVIDE .)


state 114

    (67) addop_mulop -> DIV .

    PLUS            reduce using rule 67 (addop_mulop -> DIV .)
    MINUS           reduce using rule 67 (addop_mulop -> DIV .)
    OR              reduce using rule 67 (addop_mulop -> DIV .)
    TIMES           reduce using rule 67 (addop_mulop -> DIV .)
    DIVIDE          reduce using rule 67 (addop_mulop -> DIV .)
    DIV             reduce using rule 67 (addop_mulop -> DIV .)
    MOD             reduce using rule 67 (addop_mulop -> DIV .)
    AND             reduce using rule 67 (addop_mulop -> DIV .)
    ID              reduce using rule 67 (addop_mulop -> DIV .)
    INTEGER         reduce using rule 67 (addop_mulop -> DIV .)
    REAL            reduce using rule 67 (addop_mulop -> DIV .)
    STRING          reduce using rule 67 (addop_mulop -> DIV .)
    NOT             reduce using rule 67 (addop_mulop -> DIV .)
    UPLUS           reduce using rule 67 (addop_mulop -> DIV .)
    UMINUS          reduce using rule 67 (addop_mulop -> DIV .)
    EQUALS          reduce using rule 67 (addop_mulop -> DIV .)
    LTHAN           reduce using rule 67 (addop_mulop -> DIV .)
    GTHAN           reduce using rule 67 (addop_mulop -> DIV .)
    DIFFERENT       reduce using rule 67 (addop_mulop -> DIV .)
    GEQUALS         reduce using rule 67 (addop_mulop -> DIV .)
    LEQUALS         reduce using rule 67 (addop_mulop -> DIV .)
    DO              reduce using rule 67 (addop_mulop -> DIV .)
    COMMA           reduce using rule 67 (addop_mulop -> DIV .)
    THEN            reduce using rule 67 (addop_mulop -> DIV .)
    SEMICOLON       reduce using rule 67 (addop_mulop -> DIV .)
    RPARENT         reduce using rule 67 (addop_mulop -> DIV .)
    WHILE           reduce using rule 67 (addop_mulop -> DIV .)
    REPEAT          reduce using rule 67 (addop_mulop -> DIV .)
    BEGIN           reduce using rule 67 (addop_mulop -> DIV .)
    IF              reduce using rule 67 (addop_mulop -> DIV .)
    END             reduce using rule 67 (addop_mulop -> DIV .)
    UNTIL           reduce using rule 67 (addop_mulop -> DIV .)


state 115

    (68) addop_mulop -> MOD .

    PLUS            reduce using rule 68 (addop_mulop -> MOD .)
    MINUS           reduce using rule 68 (addop_mulop -> MOD .)
    OR              reduce using rule 68 (addop_mulop -> MOD .)
    TIMES           reduce using rule 68 (addop_mulop -> MOD .)
    DIVIDE          reduce using rule 68 (addop_mulop -> MOD .)
    DIV             reduce using rule 68 (addop_mulop -> MOD .)
    MOD             reduce using rule 68 (addop_mulop -> MOD .)
    AND             reduce using rule 68 (addop_mulop -> MOD .)
    ID              reduce using rule 68 (addop_mulop -> MOD .)
    INTEGER         reduce using rule 68 (addop_mulop -> MOD .)
    REAL            reduce using rule 68 (addop_mulop -> MOD .)
    STRING          reduce using rule 68 (addop_mulop -> MOD .)
    NOT             reduce using rule 68 (addop_mulop -> MOD .)
    UPLUS           reduce using rule 68 (addop_mulop -> MOD .)
    UMINUS          reduce using rule 68 (addop_mulop -> MOD .)
    EQUALS          reduce using rule 68 (addop_mulop -> MOD .)
    LTHAN           reduce using rule 68 (addop_mulop -> MOD .)
    GTHAN           reduce using rule 68 (addop_mulop -> MOD .)
    DIFFERENT       reduce using rule 68 (addop_mulop -> MOD .)
    GEQUALS         reduce using rule 68 (addop_mulop -> MOD .)
    LEQUALS         reduce using rule 68 (addop_mulop -> MOD .)
    DO              reduce using rule 68 (addop_mulop -> MOD .)
    COMMA           reduce using rule 68 (addop_mulop -> MOD .)
    THEN            reduce using rule 68 (addop_mulop -> MOD .)
    SEMICOLON       reduce using rule 68 (addop_mulop -> MOD .)
    RPARENT         reduce using rule 68 (addop_mulop -> MOD .)
    WHILE           reduce using rule 68 (addop_mulop -> MOD .)
    REPEAT          reduce using rule 68 (addop_mulop -> MOD .)
    BEGIN           reduce using rule 68 (addop_mulop -> MOD .)
    IF              reduce using rule 68 (addop_mulop -> MOD .)
    END             reduce using rule 68 (addop_mulop -> MOD .)
    UNTIL           reduce using rule 68 (addop_mulop -> MOD .)


state 116

    (69) addop_mulop -> AND .

    PLUS            reduce using rule 69 (addop_mulop -> AND .)
    MINUS           reduce using rule 69 (addop_mulop -> AND .)
    OR              reduce using rule 69 (addop_mulop -> AND .)
    TIMES           reduce using rule 69 (addop_mulop -> AND .)
    DIVIDE          reduce using rule 69 (addop_mulop -> AND .)
    DIV             reduce using rule 69 (addop_mulop -> AND .)
    MOD             reduce using rule 69 (addop_mulop -> AND .)
    AND             reduce using rule 69 (addop_mulop -> AND .)
    ID              reduce using rule 69 (addop_mulop -> AND .)
    INTEGER         reduce using rule 69 (addop_mulop -> AND .)
    REAL            reduce using rule 69 (addop_mulop -> AND .)
    STRING          reduce using rule 69 (addop_mulop -> AND .)
    NOT             reduce using rule 69 (addop_mulop -> AND .)
    UPLUS           reduce using rule 69 (addop_mulop -> AND .)
    UMINUS          reduce using rule 69 (addop_mulop -> AND .)
    EQUALS          reduce using rule 69 (addop_mulop -> AND .)
    LTHAN           reduce using rule 69 (addop_mulop -> AND .)
    GTHAN           reduce using rule 69 (addop_mulop -> AND .)
    DIFFERENT       reduce using rule 69 (addop_mulop -> AND .)
    GEQUALS         reduce using rule 69 (addop_mulop -> AND .)
    LEQUALS         reduce using rule 69 (addop_mulop -> AND .)
    DO              reduce using rule 69 (addop_mulop -> AND .)
    COMMA           reduce using rule 69 (addop_mulop -> AND .)
    THEN            reduce using rule 69 (addop_mulop -> AND .)
    SEMICOLON       reduce using rule 69 (addop_mulop -> AND .)
    RPARENT         reduce using rule 69 (addop_mulop -> AND .)
    WHILE           reduce using rule 69 (addop_mulop -> AND .)
    REPEAT          reduce using rule 69 (addop_mulop -> AND .)
    BEGIN           reduce using rule 69 (addop_mulop -> AND .)
    IF              reduce using rule 69 (addop_mulop -> AND .)
    END             reduce using rule 69 (addop_mulop -> AND .)
    UNTIL           reduce using rule 69 (addop_mulop -> AND .)


state 117

    (75) factor -> NOT factor .

    PLUS            reduce using rule 75 (factor -> NOT factor .)
    MINUS           reduce using rule 75 (factor -> NOT factor .)
    OR              reduce using rule 75 (factor -> NOT factor .)
    TIMES           reduce using rule 75 (factor -> NOT factor .)
    DIVIDE          reduce using rule 75 (factor -> NOT factor .)
    DIV             reduce using rule 75 (factor -> NOT factor .)
    MOD             reduce using rule 75 (factor -> NOT factor .)
    AND             reduce using rule 75 (factor -> NOT factor .)
    ID              reduce using rule 75 (factor -> NOT factor .)
    INTEGER         reduce using rule 75 (factor -> NOT factor .)
    REAL            reduce using rule 75 (factor -> NOT factor .)
    STRING          reduce using rule 75 (factor -> NOT factor .)
    NOT             reduce using rule 75 (factor -> NOT factor .)
    UPLUS           reduce using rule 75 (factor -> NOT factor .)
    UMINUS          reduce using rule 75 (factor -> NOT factor .)
    EQUALS          reduce using rule 75 (factor -> NOT factor .)
    LTHAN           reduce using rule 75 (factor -> NOT factor .)
    GTHAN           reduce using rule 75 (factor -> NOT factor .)
    DIFFERENT       reduce using rule 75 (factor -> NOT factor .)
    GEQUALS         reduce using rule 75 (factor -> NOT factor .)
    LEQUALS         reduce using rule 75 (factor -> NOT factor .)
    DO              reduce using rule 75 (factor -> NOT factor .)
    COMMA           reduce using rule 75 (factor -> NOT factor .)
    THEN            reduce using rule 75 (factor -> NOT factor .)
    SEMICOLON       reduce using rule 75 (factor -> NOT factor .)
    RPARENT         reduce using rule 75 (factor -> NOT factor .)
    WHILE           reduce using rule 75 (factor -> NOT factor .)
    REPEAT          reduce using rule 75 (factor -> NOT factor .)
    BEGIN           reduce using rule 75 (factor -> NOT factor .)
    IF              reduce using rule 75 (factor -> NOT factor .)
    END             reduce using rule 75 (factor -> NOT factor .)
    UNTIL           reduce using rule 75 (factor -> NOT factor .)


state 118

    (45) repeat_statement -> REPEAT statement UNTIL expr .

    ID              reduce using rule 45 (repeat_statement -> REPEAT statement UNTIL expr .)
    WHILE           reduce using rule 45 (repeat_statement -> REPEAT statement UNTIL expr .)
    REPEAT          reduce using rule 45 (repeat_statement -> REPEAT statement UNTIL expr .)
    BEGIN           reduce using rule 45 (repeat_statement -> REPEAT statement UNTIL expr .)
    IF              reduce using rule 45 (repeat_statement -> REPEAT statement UNTIL expr .)
    SEMICOLON       reduce using rule 45 (repeat_statement -> REPEAT statement UNTIL expr .)
    END             reduce using rule 45 (repeat_statement -> REPEAT statement UNTIL expr .)
    UNTIL           reduce using rule 45 (repeat_statement -> REPEAT statement UNTIL expr .)


state 119

    (40) if1 -> IF expr_list THEN if1 . ELSE if1
    (43) if2 -> IF expr_list THEN if1 . ELSE if2
    (38) if_statement -> if1 .

    ELSE            shift and go to state 129
    ID              reduce using rule 38 (if_statement -> if1 .)
    WHILE           reduce using rule 38 (if_statement -> if1 .)
    REPEAT          reduce using rule 38 (if_statement -> if1 .)
    BEGIN           reduce using rule 38 (if_statement -> if1 .)
    IF              reduce using rule 38 (if_statement -> if1 .)
    SEMICOLON       reduce using rule 38 (if_statement -> if1 .)
    END             reduce using rule 38 (if_statement -> if1 .)
    UNTIL           reduce using rule 38 (if_statement -> if1 .)


state 120

    (42) if2 -> IF expr_list THEN if_statement .

    ID              reduce using rule 42 (if2 -> IF expr_list THEN if_statement .)
    WHILE           reduce using rule 42 (if2 -> IF expr_list THEN if_statement .)
    REPEAT          reduce using rule 42 (if2 -> IF expr_list THEN if_statement .)
    BEGIN           reduce using rule 42 (if2 -> IF expr_list THEN if_statement .)
    IF              reduce using rule 42 (if2 -> IF expr_list THEN if_statement .)
    SEMICOLON       reduce using rule 42 (if2 -> IF expr_list THEN if_statement .)
    END             reduce using rule 42 (if2 -> IF expr_list THEN if_statement .)
    UNTIL           reduce using rule 42 (if2 -> IF expr_list THEN if_statement .)


state 121

    (47) expr_list -> expr COMMA expr_list .

    THEN            reduce using rule 47 (expr_list -> expr COMMA expr_list .)
    RPARENT         reduce using rule 47 (expr_list -> expr COMMA expr_list .)


state 122

    (23) procedure_declaration -> PROCEDURE ID LPARENT param_section RPARENT SEMICOLON .

    PROCEDURE       reduce using rule 23 (procedure_declaration -> PROCEDURE ID LPARENT param_section RPARENT SEMICOLON .)
    FUNCTION        reduce using rule 23 (procedure_declaration -> PROCEDURE ID LPARENT param_section RPARENT SEMICOLON .)
    BEGIN           reduce using rule 23 (procedure_declaration -> PROCEDURE ID LPARENT param_section RPARENT SEMICOLON .)


state 123

    (25) param_section -> identifier_list TWOPOINTS types . SEMICOLON param_section

    SEMICOLON       shift and go to state 130


state 124

    (24) function_declaration -> FUNCTION ID LPARENT param_section RPARENT TWOPOINTS . types SEMICOLON
    (12) types -> . INTEGER
    (13) types -> . REAL
    (14) types -> . STRING
    (15) types -> . BOOLEAN
    (16) types -> . CHAR
    (17) types -> . ID

    INTEGER         shift and go to state 31
    REAL            shift and go to state 32
    STRING          shift and go to state 33
    BOOLEAN         shift and go to state 34
    CHAR            shift and go to state 35
    ID              shift and go to state 29

    types                          shift and go to state 131

state 125

    (27) compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON .

    $end            reduce using rule 27 (compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON .)
    ID              reduce using rule 27 (compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON .)
    WHILE           reduce using rule 27 (compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON .)
    REPEAT          reduce using rule 27 (compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON .)
    BEGIN           reduce using rule 27 (compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON .)
    IF              reduce using rule 27 (compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON .)
    SEMICOLON       reduce using rule 27 (compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON .)
    END             reduce using rule 27 (compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON .)
    UNTIL           reduce using rule 27 (compound_statement -> BEGIN statement SEMICOLON statement END SEMICOLON .)


state 126

    (37) procedure_call -> ID LPARENT expr_list RPARENT SEMICOLON .

    ID              reduce using rule 37 (procedure_call -> ID LPARENT expr_list RPARENT SEMICOLON .)
    WHILE           reduce using rule 37 (procedure_call -> ID LPARENT expr_list RPARENT SEMICOLON .)
    REPEAT          reduce using rule 37 (procedure_call -> ID LPARENT expr_list RPARENT SEMICOLON .)
    BEGIN           reduce using rule 37 (procedure_call -> ID LPARENT expr_list RPARENT SEMICOLON .)
    IF              reduce using rule 37 (procedure_call -> ID LPARENT expr_list RPARENT SEMICOLON .)
    SEMICOLON       reduce using rule 37 (procedure_call -> ID LPARENT expr_list RPARENT SEMICOLON .)
    END             reduce using rule 37 (procedure_call -> ID LPARENT expr_list RPARENT SEMICOLON .)
    UNTIL           reduce using rule 37 (procedure_call -> ID LPARENT expr_list RPARENT SEMICOLON .)


state 127

    (49) relop_simple_expr -> relop simple_expr relop_simple_expr .

    DO              reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    COMMA           reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    THEN            reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    SEMICOLON       reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    RPARENT         reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    ID              reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    WHILE           reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    REPEAT          reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    BEGIN           reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    IF              reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    END             reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)
    UNTIL           reduce using rule 49 (relop_simple_expr -> relop simple_expr relop_simple_expr .)


state 128

    (58) simple_expr -> uplus_uminus factor addop_mulop factor . simple_expr
    (57) simple_expr -> . uplus_uminus factor
    (58) simple_expr -> . uplus_uminus factor addop_mulop factor simple_expr
    (59) uplus_uminus -> . UPLUS
    (60) uplus_uminus -> . UMINUS
    (61) uplus_uminus -> .

  ! shift/reduce conflict for UPLUS resolved as shift
  ! shift/reduce conflict for UMINUS resolved as shift
    UPLUS           shift and go to state 67
    UMINUS          shift and go to state 68
    PLUS            reduce using rule 61 (uplus_uminus -> .)
    MINUS           reduce using rule 61 (uplus_uminus -> .)
    OR              reduce using rule 61 (uplus_uminus -> .)
    TIMES           reduce using rule 61 (uplus_uminus -> .)
    DIVIDE          reduce using rule 61 (uplus_uminus -> .)
    DIV             reduce using rule 61 (uplus_uminus -> .)
    MOD             reduce using rule 61 (uplus_uminus -> .)
    AND             reduce using rule 61 (uplus_uminus -> .)
    ID              reduce using rule 61 (uplus_uminus -> .)
    INTEGER         reduce using rule 61 (uplus_uminus -> .)
    REAL            reduce using rule 61 (uplus_uminus -> .)
    STRING          reduce using rule 61 (uplus_uminus -> .)
    NOT             reduce using rule 61 (uplus_uminus -> .)
    EQUALS          reduce using rule 61 (uplus_uminus -> .)
    LTHAN           reduce using rule 61 (uplus_uminus -> .)
    GTHAN           reduce using rule 61 (uplus_uminus -> .)
    DIFFERENT       reduce using rule 61 (uplus_uminus -> .)
    GEQUALS         reduce using rule 61 (uplus_uminus -> .)
    LEQUALS         reduce using rule 61 (uplus_uminus -> .)
    DO              reduce using rule 61 (uplus_uminus -> .)
    COMMA           reduce using rule 61 (uplus_uminus -> .)
    THEN            reduce using rule 61 (uplus_uminus -> .)
    SEMICOLON       reduce using rule 61 (uplus_uminus -> .)
    RPARENT         reduce using rule 61 (uplus_uminus -> .)
    WHILE           reduce using rule 61 (uplus_uminus -> .)
    REPEAT          reduce using rule 61 (uplus_uminus -> .)
    BEGIN           reduce using rule 61 (uplus_uminus -> .)
    IF              reduce using rule 61 (uplus_uminus -> .)
    END             reduce using rule 61 (uplus_uminus -> .)
    UNTIL           reduce using rule 61 (uplus_uminus -> .)

  ! UPLUS           [ reduce using rule 61 (uplus_uminus -> .) ]
  ! UMINUS          [ reduce using rule 61 (uplus_uminus -> .) ]

    uplus_uminus                   shift and go to state 66
    simple_expr                    shift and go to state 132

state 129

    (40) if1 -> IF expr_list THEN if1 ELSE . if1
    (43) if2 -> IF expr_list THEN if1 ELSE . if2
    (40) if1 -> . IF expr_list THEN if1 ELSE if1
    (41) if1 -> .
    (42) if2 -> . IF expr_list THEN if_statement
    (43) if2 -> . IF expr_list THEN if1 ELSE if2

  ! shift/reduce conflict for IF resolved as shift
    IF              shift and go to state 48
    ID              reduce using rule 41 (if1 -> .)
    WHILE           reduce using rule 41 (if1 -> .)
    REPEAT          reduce using rule 41 (if1 -> .)
    BEGIN           reduce using rule 41 (if1 -> .)
    SEMICOLON       reduce using rule 41 (if1 -> .)
    END             reduce using rule 41 (if1 -> .)
    UNTIL           reduce using rule 41 (if1 -> .)
    ELSE            reduce using rule 41 (if1 -> .)

  ! IF              [ reduce using rule 41 (if1 -> .) ]

    if1                            shift and go to state 133
    if2                            shift and go to state 134

state 130

    (25) param_section -> identifier_list TWOPOINTS types SEMICOLON . param_section
    (25) param_section -> . identifier_list TWOPOINTS types SEMICOLON param_section
    (26) param_section -> .
    (18) identifier_list -> . ID
    (19) identifier_list -> . ID COMMA identifier_list

    RPARENT         reduce using rule 26 (param_section -> .)
    ID              shift and go to state 19

    identifier_list                shift and go to state 73
    param_section                  shift and go to state 135

state 131

    (24) function_declaration -> FUNCTION ID LPARENT param_section RPARENT TWOPOINTS types . SEMICOLON

    SEMICOLON       shift and go to state 136


state 132

    (58) simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .

    EQUALS          reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    LTHAN           reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    GTHAN           reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    DIFFERENT       reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    GEQUALS         reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    LEQUALS         reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    DO              reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    COMMA           reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    THEN            reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    SEMICOLON       reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    RPARENT         reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    ID              reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    WHILE           reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    REPEAT          reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    BEGIN           reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    IF              reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    END             reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)
    UNTIL           reduce using rule 58 (simple_expr -> uplus_uminus factor addop_mulop factor simple_expr .)


state 133

    (40) if1 -> IF expr_list THEN if1 ELSE if1 .

    ID              reduce using rule 40 (if1 -> IF expr_list THEN if1 ELSE if1 .)
    WHILE           reduce using rule 40 (if1 -> IF expr_list THEN if1 ELSE if1 .)
    REPEAT          reduce using rule 40 (if1 -> IF expr_list THEN if1 ELSE if1 .)
    BEGIN           reduce using rule 40 (if1 -> IF expr_list THEN if1 ELSE if1 .)
    IF              reduce using rule 40 (if1 -> IF expr_list THEN if1 ELSE if1 .)
    SEMICOLON       reduce using rule 40 (if1 -> IF expr_list THEN if1 ELSE if1 .)
    END             reduce using rule 40 (if1 -> IF expr_list THEN if1 ELSE if1 .)
    UNTIL           reduce using rule 40 (if1 -> IF expr_list THEN if1 ELSE if1 .)
    ELSE            reduce using rule 40 (if1 -> IF expr_list THEN if1 ELSE if1 .)


state 134

    (43) if2 -> IF expr_list THEN if1 ELSE if2 .

    ID              reduce using rule 43 (if2 -> IF expr_list THEN if1 ELSE if2 .)
    WHILE           reduce using rule 43 (if2 -> IF expr_list THEN if1 ELSE if2 .)
    REPEAT          reduce using rule 43 (if2 -> IF expr_list THEN if1 ELSE if2 .)
    BEGIN           reduce using rule 43 (if2 -> IF expr_list THEN if1 ELSE if2 .)
    IF              reduce using rule 43 (if2 -> IF expr_list THEN if1 ELSE if2 .)
    SEMICOLON       reduce using rule 43 (if2 -> IF expr_list THEN if1 ELSE if2 .)
    END             reduce using rule 43 (if2 -> IF expr_list THEN if1 ELSE if2 .)
    UNTIL           reduce using rule 43 (if2 -> IF expr_list THEN if1 ELSE if2 .)


state 135

    (25) param_section -> identifier_list TWOPOINTS types SEMICOLON param_section .

    RPARENT         reduce using rule 25 (param_section -> identifier_list TWOPOINTS types SEMICOLON param_section .)


state 136

    (24) function_declaration -> FUNCTION ID LPARENT param_section RPARENT TWOPOINTS types SEMICOLON .

    PROCEDURE       reduce using rule 24 (function_declaration -> FUNCTION ID LPARENT param_section RPARENT TWOPOINTS types SEMICOLON .)
    FUNCTION        reduce using rule 24 (function_declaration -> FUNCTION ID LPARENT param_section RPARENT TWOPOINTS types SEMICOLON .)
    BEGIN           reduce using rule 24 (function_declaration -> FUNCTION ID LPARENT param_section RPARENT TWOPOINTS types SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 22 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 22 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 22 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 22 resolved as shift
WARNING: shift/reduce conflict for IF in state 22 resolved as shift
WARNING: shift/reduce conflict for ID in state 37 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 37 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 37 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 37 resolved as shift
WARNING: shift/reduce conflict for IF in state 37 resolved as shift
WARNING: shift/reduce conflict for ID in state 37 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 37 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 37 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 37 resolved as shift
WARNING: shift/reduce conflict for IF in state 37 resolved as shift
WARNING: shift/reduce conflict for ID in state 38 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 38 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 38 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 38 resolved as shift
WARNING: shift/reduce conflict for IF in state 38 resolved as shift
WARNING: shift/reduce conflict for ID in state 38 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 38 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 38 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 38 resolved as shift
WARNING: shift/reduce conflict for IF in state 38 resolved as shift
WARNING: shift/reduce conflict for ID in state 39 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 39 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 39 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 39 resolved as shift
WARNING: shift/reduce conflict for IF in state 39 resolved as shift
WARNING: shift/reduce conflict for ID in state 39 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 39 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 39 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 39 resolved as shift
WARNING: shift/reduce conflict for IF in state 39 resolved as shift
WARNING: shift/reduce conflict for ID in state 40 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 40 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 40 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 40 resolved as shift
WARNING: shift/reduce conflict for ID in state 40 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 40 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 40 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 40 resolved as shift
WARNING: shift/reduce conflict for IF in state 40 resolved as shift
WARNING: shift/reduce conflict for ID in state 41 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 41 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 41 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 41 resolved as shift
WARNING: shift/reduce conflict for IF in state 41 resolved as shift
WARNING: shift/reduce conflict for ID in state 41 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 41 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 41 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 41 resolved as shift
WARNING: shift/reduce conflict for IF in state 41 resolved as shift
WARNING: shift/reduce conflict for ID in state 42 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 42 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 42 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 42 resolved as shift
WARNING: shift/reduce conflict for IF in state 42 resolved as shift
WARNING: shift/reduce conflict for ID in state 42 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 42 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 42 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 42 resolved as shift
WARNING: shift/reduce conflict for IF in state 42 resolved as shift
WARNING: shift/reduce conflict for UPLUS in state 46 resolved as shift
WARNING: shift/reduce conflict for UMINUS in state 46 resolved as shift
WARNING: shift/reduce conflict for ID in state 47 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 47 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 47 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 47 resolved as shift
WARNING: shift/reduce conflict for IF in state 47 resolved as shift
WARNING: shift/reduce conflict for UPLUS in state 48 resolved as shift
WARNING: shift/reduce conflict for UMINUS in state 48 resolved as shift
WARNING: shift/reduce conflict for ID in state 54 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 54 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 54 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 54 resolved as shift
WARNING: shift/reduce conflict for IF in state 54 resolved as shift
WARNING: shift/reduce conflict for UPLUS in state 62 resolved as shift
WARNING: shift/reduce conflict for UMINUS in state 62 resolved as shift
WARNING: shift/reduce conflict for UPLUS in state 63 resolved as shift
WARNING: shift/reduce conflict for UMINUS in state 63 resolved as shift
WARNING: shift/reduce conflict for ID in state 66 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 66 resolved as shift
WARNING: shift/reduce conflict for REAL in state 66 resolved as shift
WARNING: shift/reduce conflict for STRING in state 66 resolved as shift
WARNING: shift/reduce conflict for NOT in state 66 resolved as shift
WARNING: shift/reduce conflict for ID in state 81 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 81 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 81 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 81 resolved as shift
WARNING: shift/reduce conflict for IF in state 81 resolved as shift
WARNING: shift/reduce conflict for ID in state 81 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 81 resolved as shift
WARNING: shift/reduce conflict for REPEAT in state 81 resolved as shift
WARNING: shift/reduce conflict for BEGIN in state 81 resolved as shift
WARNING: shift/reduce conflict for IF in state 81 resolved as shift
WARNING: shift/reduce conflict for UPLUS in state 83 resolved as shift
WARNING: shift/reduce conflict for UMINUS in state 83 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 90 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 90 resolved as shift
WARNING: shift/reduce conflict for OR in state 90 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 90 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 90 resolved as shift
WARNING: shift/reduce conflict for DIV in state 90 resolved as shift
WARNING: shift/reduce conflict for MOD in state 90 resolved as shift
WARNING: shift/reduce conflict for AND in state 90 resolved as shift
WARNING: shift/reduce conflict for ID in state 95 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 95 resolved as shift
WARNING: shift/reduce conflict for REAL in state 95 resolved as shift
WARNING: shift/reduce conflict for STRING in state 95 resolved as shift
WARNING: shift/reduce conflict for NOT in state 95 resolved as shift
WARNING: shift/reduce conflict for UPLUS in state 96 resolved as shift
WARNING: shift/reduce conflict for UMINUS in state 96 resolved as shift
WARNING: shift/reduce conflict for IF in state 97 resolved as shift
WARNING: shift/reduce conflict for UPLUS in state 98 resolved as shift
WARNING: shift/reduce conflict for UMINUS in state 98 resolved as shift
WARNING: shift/reduce conflict for ID in state 108 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 108 resolved as shift
WARNING: shift/reduce conflict for REAL in state 108 resolved as shift
WARNING: shift/reduce conflict for STRING in state 108 resolved as shift
WARNING: shift/reduce conflict for NOT in state 108 resolved as shift
WARNING: shift/reduce conflict for UPLUS in state 128 resolved as shift
WARNING: shift/reduce conflict for UMINUS in state 128 resolved as shift
WARNING: shift/reduce conflict for IF in state 129 resolved as shift
WARNING: reduce/reduce conflict in state 22 resolved using rule (statement -> <empty>)
WARNING: rejected rule (if1 -> <empty>) in state 22
WARNING: reduce/reduce conflict in state 37 resolved using rule (statement -> <empty>)
WARNING: rejected rule (if1 -> <empty>) in state 37
WARNING: reduce/reduce conflict in state 38 resolved using rule (statement -> <empty>)
WARNING: rejected rule (if1 -> <empty>) in state 38
WARNING: reduce/reduce conflict in state 39 resolved using rule (statement -> <empty>)
WARNING: rejected rule (if1 -> <empty>) in state 39
WARNING: reduce/reduce conflict in state 40 resolved using rule (statement -> <empty>)
WARNING: rejected rule (if1 -> <empty>) in state 40
WARNING: reduce/reduce conflict in state 41 resolved using rule (statement -> <empty>)
WARNING: rejected rule (if1 -> <empty>) in state 41
WARNING: reduce/reduce conflict in state 42 resolved using rule (statement -> <empty>)
WARNING: rejected rule (if1 -> <empty>) in state 42
WARNING: reduce/reduce conflict in state 47 resolved using rule (statement -> <empty>)
WARNING: rejected rule (if1 -> <empty>) in state 47
WARNING: reduce/reduce conflict in state 54 resolved using rule (statement -> <empty>)
WARNING: rejected rule (if1 -> <empty>) in state 54
WARNING: reduce/reduce conflict in state 81 resolved using rule (statement -> <empty>)
WARNING: rejected rule (if1 -> <empty>) in state 81
WARNING: reduce/reduce conflict in state 90 resolved using rule (simple_expr -> uplus_uminus factor)
WARNING: rejected rule (addop_mulop -> <empty>) in state 90
